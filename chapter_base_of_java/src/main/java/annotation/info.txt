
Аннотации в Java и их обработка в RUNTIME с помощью рефлексии.
Обработка аннотаций на уровне исходников.
Модификация байт-кода с помощью Instrumentation.

{https://sysout.ru/annotatsii-v-java-i-ih-obrabotka-v-runtime-s-pomoshhyu-refleksii/}
{https://sysout.ru/obrabotka-annotatsij-na-urovne-ishodnikov/}
{https://sysout.ru/modifikatsiya-bajt-koda-s-pomoshhyu-instrumentation/}
{https://github.com/myluckagain/sysout/tree/master/annotations-runtime/src/main/java/ru/sysout/annotationsruntime}
{https://github.com/myluckagain/sysout/tree/master/annotation-use}
{https://github.com/myluckagain/sysout/tree/master/annotation-processing}
{https://betacode.net/10197/java-annotation}

Аннотации – это своего рода маркеры, которые служат знаком либо компилятору,
либо обработчику скомпилированных классов, либо самому приложению во время его
выполнения – знаком что-то сделать.
Аннотации представляют из себя дескрипторы, включаемые в текст программы, и используются
для хранения метаданных программного кода, необходимых на разных этапах жизненного
цикла программы.
Информация, хранимая в аннотациях, может использоваться соответствующими обработчиками
для создания необходимых вспомогательных файлов или для маркировки классов, полей
и т.д.
Аннотациями мы помечаем куски кода и потом эти куски динамически обрабатываем.

Для аннотаций всегда нужен обработчик, сами они ничего не делают.
Создать новую аннотацию в Java легко. Также легко аннотировать ею класс, метод или другой
элемент. Но толку от этого кода будет мало, поскольку для любой аннотации нужен обработчик.
И вот тут все становится намного сложнее, поскольку написать можно совершенно разные
обработчики аннотаций, и они могут обрабатывать аннотацию на разных этапах – от компиляции
до времени выполнения кода.

Есть обработчики, которые на основе аннотаций трансформируют уже скомпилированные .class
файлы. Пример – обфускатор. Можно пометить своей аннотаций классы, которые не надо трогать,
и написать обработчик, который опирается на аннотацию, чтобы решить, трансформировать ли
класс.

Есть обработчики, которые в RUNTIME меняют код с помощью библиотеки Java Reflection.

А можно обрабатывать аннотации на самом начальном уровне – в исходниках, еще до компиляции
файлов. Это означает, что аннотация доступна только в исходниках, а в .class-файлах и в
RUNTIME ее уже нет.

Еще пример обработчика – тестовый фреймворк JUnit.
Для него мы помечаем метод аннотацией @Test, и он обрабатывает этот метод как
тестовый. Вне фреймворка аннотация  @Test ничего не значит.

Другой пример – ORM-фреймворк Hibernate.  Еще есть Spring Framework,
проект Lombok.

@Target и @Retention – это мета-аннотации, то есть аннотации, которые применяются
к аннотации.

Значение ElementType.METHOD в @Target показывает, что наша аннотация @Test
применима к методам, то есть с помощью нее можно аннотировать только метод:

@Test
public static void m1() {
}

А вообще аннотации можно применять практически к любому элементу кода – классу,
параметрам, полям…Просто в нашем случае требуется аннотировать только методы,
что мы и указываем в определении аннотации. Если теперь в коде применить
аннотацию @Test к полю, классу или другому элементу, то компилятор выдаст ошибку.

@Retention(RetentionPolicy.RUNTIME) она, как и @Target, доступна в JDK по
умолчанию и служит для оформления пользовательских аннотаций.

Вообще есть три уровня RetentionPolicy:

RetentionPolicy.SOURCE
RetentionPolicy.CLASS (действует по умолчанию, если метааннотация @Retention
не указана)
RetentionPolicy.RUNTIME

“Retention” переводится как “сохранение”, “удержание”, имеется в виду где
(на каком этапе) сохраняются/выживают аннотации.

Ниже приведены примеры объявления элементов аннотации, имеющих допустимые типы.

public @interface BugReport {
enum Status { UNCONFIRMED, CONFIRMED, FIXED, NOTABUG };
boolean showStopper() default false;
String assignedToO default "[none]";
Class<?> testCaseO default Void.class;
Status status() default Status.UNCONFIRMED;
Reference ref() default @Reference(); // тип аннотации String[] reportedBy();

Внимание! ======================================================================
Устанавливаемые по умолчанию значения (...default "[none]" или ...default false и
другие примеры) не хранятся вместе с аннотацией, а вычисляются динамически.
Так, если заменить значение, устанавливаемое по умолчанию в элементе assignedTo,
строковым значением "[]" и скомпилировать интерфейс BugReport заново, в аннотации
@BugReport (severity=10) будет использоваться новое устанавливаемое по умолчанию
значение — даже в тех файлах классов, которые были скомпилированы до изменения
этого значения.
================================================================================

Если элементы в аннотации не указаны, потому что они просто отсутствуют в
аннотации или все они принимают значения, устанавливаемые по умолчанию, то
круглые скобки не требуются.
Например, аннотация

@BugReport

равнозначна аннотации

@BugReport(assignedTo="[none]", severity=0)

Подобная аннотация называется маркерной.

Другим специальным сокращением является однозначная аннотация.
Если элемент аннотации имеет специальное имя value и больше никаких элементов
не указано, то имя элемента и знак = могут быть опущены.
Так, если определить интерфейс аннотаций ActionListenerFor, упоминавшийся в предыдущем
разделе, следующим образом:
public @interface ActionListenerFor {
String value();
}

то сами аннотации можно записать так:

@ActionListenerFor("yellowButton") а не так, как показано ниже.
©ActionListenerFor(value="yellowButton")

У каждого элемента может быть несколько аннотаций, как показано ниже.
©BugReport(showStopper=true, reportedBy="Joe")
©BugReport(reportedBy={"Harry", "Carl"})
void myMethod()
Если автор аннотации объявил ее повторяющейся, такую аннотацию можно
повторять неоднократно, как демонстрируется в следующем примере кода:
©BugReport(showStopper=true, reportedBy="Joe")
©BugReport(reportedBy={"Harry", "Carl"})
public void checkRandomlnsertions()


Внимание! ====================================================================
Элемент аннотации вообще не может принимать пустое значение null.
Даже по умолчанию не допускается устанавливать пустое значение null.
Это не очень удобно, поскольку для установки по умолчанию придется
выбирать другие значения вроде "" или Void.class.
===============================================================================

Если в качестве значения элемента аннотации указывается массив, значения
элементов такого массива заключаются в фигурные скобки:

@BugReport(. . reportedBy={"Harry", "Carl”})

Если же элемент аннотации принимает единственное значение, фигурные скобки
можно опустить:

@BugReport(. . reportedBy="Joe") // допускается и подобно {"Joe"}

В качестве элемента аннотации может служить какая-нибудь другая аннотация.
Это дает возможность создавать довольно сложные аннотации, как показано в
приведенном ниже примере.

@BugReport(ref=@Reference(id="3352627"), . . .)

Аннотации могут встречаться и во многих других местах прикладного кода.
Эти места можно разделить на две категории:
объявления и места употребления типов данных.
Аннотации могут появляться в объявлениях следующих элементов кода.
• Пакеты.
• Классы (включая и перечисления).
• Методы.
• Конструкторы.
• Переменные экземпляра (включая и константы перечислимого типа).
• Локальные переменные.
• Переменные параметров.
• Параметры типа.

Параметр типа в обобщенном классе или методе может быть аннотирован следующим
образом:

public class Cache<@Immutable V> { ... }

Пакет аннотируется в отдельном файле package-info.java.
Этот файл содержит только операторы объявления и импорта пакета с
предшествующими аннотациями, как показано ниже.
Обратите внимание на то, что оператор import следует после оператора
package, в котором объявляется пакет.
/**
    Документирующий комментарий на уровне пакета
*/
@GPL(version="3")
package com.horstmann.corejava;
import org.gnu.GPL;

На заметку! ===================================================================
Аннотации всех локальных переменных отбрасываются при компилировании класса.
Следовательно, они могут быть обработаны только на уровне исходного кода.
Аналогично аннотации пакетов не сохраняются вне уровня исходного кода.
===============================================================================

В следующем примере кода аннотацией утверждается, что параметр userid
объявляемого метода не является пустым:

public User getUser(@NonNull String userid)

На заметку! ==================================================================
Аннотация @NonNull является частью каркаса Checker Framework
(http://types.cs.Washington.edu/checker-framework).
С помощью этого каркаса можно включать утверждения в прикладную
программу, например, утверждение, что параметр не является пустым
или относится к типу String и содержит регулярное выражение. В
таком случае инструментальное средство статистического анализа
проверит достоверность утверждений в данном теле исходного кода.
===============================================================================

Подобные аннотации можно указывать в следующих местах употребления типов данных.
• Вместе с аргументами обобщенного типа: List<@NonNull String>,
    Comparator. <@NonNull String> reverseOrder().
• В любом месте массива: @NonNull String[][] words (элемент массива
    words[i][j] не является пустым), String @NonNull [][] words (массив
    words не является пустым), String[] @NonNull [] words (элемент массива
    words [i] не является пустым).
• В суперклассах и реализуемых интерфейсах: class Warning extends @Localized Message.
• В вызовах конструкторов: new @Localized String (...).
• Во вложенных типах: Map.@Localized Entry.
• В операции приведения и проверки типов instanceof:
    (@Localized String) text, if (text instanceof @Localized String).
    (Аннотации служат для употребления только внешними инструментальными
    средствами. Они не оказывают никакого влияния на поведение операции
    приведения и проверки типов instanceof.)
• В местах указания исключений: public String read() throws @Localized IOException.
• Вместе с метасимволами подстановки и ограничениями типов:
    List<@ Localized ? extends Message>, List<? Extends @Localized Message>.
• В ссылках на методы и конструкторы: @Localized Message:: getText.

Имеются все же некоторые методы употребления типов, где аннотации не допускаются. Ниже приведены характерные тому примеры.
@NonNull String.class // ОШИБКА: литерал класса не
// подлежит аннотированию!
import java.lang.@NonNull String; // ОШИБКА: импорт не
// подлежит аннотированию!

Рассмотрим в качестве примера следующее объявление метода:

public User getUser(@NonNull String userid)

Если аннотацию @NonNull можно применять как в параметрах, так и в местах
употребления типов, то параметр userid аннотируется, а тип параметра
обозначается как @NonNull String.

	Аннотирование по ссылке this
Допустим, требуется аннотировать параметры, которые не изменяются методом:

public class Point {
public boolean equals(@Readonly Object other) { ... }
}

В таком случае инструментальное средство, обрабатывающее данную аннотацию,
после анализа следующего вызова:
р.equals(q)
посчитает, что параметр q не изменился.
А как насчет ссылки р? При вызове данного метода переменная this привязывается
к ссылке р. Но ведь переменная this вообще не объявляется, а следовательно,
она и не может быть аннотирована.

На самом деле эту переменную можно объявить с помощью редко употребляемой
разновидности синтаксиса, чтобы ввести аннотацию следующим образом:

public class Point {
    public boolean equals(
        @Readonly Point this,
        @ReadOnly Object other) { ... }
}
Первый параметр в приведенном выше примере кода называется параметром получателя.
Он должен непременно называться this. Его тип относится к тому классу, объект которого
создается.

На заметку! ===================================================================
Параметром получателя можно снабдить только методы, но не конструкторы!!!
По существу, ссылка this в конструкторе не является объектом данного типа до
тех пор, пока конструктор не завершится. Напротив, аннотация, размещаемая в
конструкторе, описывает конструируемый объект.
===============================================================================

Таблица 8.2. Стандартные аннотации
Интерфейс аннотаций     |    Применение         |    Назначение
Deprecated              |   Все элементы кода  | Помечает элемент кода как не рекомендуемый для применения
SuppressWarnings        |   Все элементы кода, кроме пакетов и аннотаций | Подавляет предупреждения указанного типа
SafeVarargs             |   Методы и конструкторы | Утверждает, что аргументы переменной длины безопасны для употребления
Override                |   Методы | Проверяет, переопределяет ли данный метод соответствующий метод из суперкласса
FunctionalInterface     |   Интерфейсы | Обозначает интерфейс как функциональный с единственным абстрактным методом
PostConstruct,PreDestroy |  Методы | Помеченный метод должен вызываться сразу же после создания или непосредственно перед удалением
Resource                |   Классы, интерфейсы, методы, поля | Если это класс или интерфейс, помечает его как ресурс для использования в каком-нибудь другом месте. А если это метод или поле, то помечает его как ресурс для "внедрения"
Resources               |   Классы, интерфейсы | Помечает массив ресурсов
Generated               |   Все элементы кода  | Помечает элемент как исходный код, сгенерированный каким-нибудь инструментальным средством
Target                  |   Аннотации | Обозначает элементы, к которым может быть применена данная аннотация
Retention               |   Аннотации | Обозначает, как долго должна сохраняться данная аннотация
Documented              |   Аннотации | Обозначает, что данная аннотация должна быть включена в документацию на аннотируемые элементы кода
Inherited               |   Аннотации | Обозначает, что если данная аннотация применяется к классу, она будет автоматически наследоваться всеми его подклассами
Repeatable              |   Аннотации | Обозначает, что данную аннотацию можно неоднократно применять к одному и тому же элементу

	Аннотации для компиляции
Аннотация @Deprecated может присоединяться к любым элементам, применение
которых впредь не рекомендуется. В таком случае компилятор будет выдавать
соответствующее предупреждение, если нерекомендуемый элемент все-таки
применяется в исходном коде. Эта аннотация имеет то же назначение, что и
дескриптор @deprecated в Javadoc.
Аннотация @SuppressWarnings указывает компилятору подавлять предупреждения
определенного типа, как показано в приведенном ниже примере.

@SuppressWarnings("unchecked”)

Аннотация @Override применяется только к методам. Компилятор проверяет, чтобы
метод с такой аннотацией действительно переопределял соответствующий метод из
суперкласса. Так, если сделать приведенное ниже объявление, компилятор выдаст
ошибку, поскольку метод equals() не переопределяет аналогичный метод equals()
из класса Object. Этот метод имеет параметр типа Object, а не MyClass.
public MyClass {
@Override public boolean equals(MyClass other);
}

Аннотация @Generated предназначена для использования инструментальными средствами
генерирования кода. Любой генерируемый исходный код может снабжаться аннотациями,
чтобы отличаться от кода, предоставляемого программистом.
Например, редактор кода может скрывать сгенерированный код, а генератор кода
— удалять более старые версии сгенерированного кода. Каждая такая аннотация
должна содержать уникальный идентификатор для генератора кода. Символьные
строки даты (в формате ISO 8601) и комментариев указывать необязательно.
Ниже приведен характерный пример аннотации для генерирования кода.

@Generated("com.horstmann.beanproperty", "2008-01-04T12:08:56.235-0700");

Мета-аннотация @Target применяется к аннотации, ограничивая те элементы, которые
должны быть снабжены данной аннотацией, как показано в приведенном ниже
примере.
@Target{{ElementType.TYPE, ElementType.METHOD})
public @interface BugReport

Указывать можно любое количество типов элементов, заключая их в фигурные скобки.

Таблица 8.3. Типы элементов для мета-аннотации @Target
Тип элемента | Применение аннотации
ANNOTATIGNJTYPE | Объявления типов аннотаций
PACKAGE | Пакеты
TYPE | Классы (включая перечисления) и интерфейсы (включая типы аннотаций)
METHOD | Методы
CONSTRUCTOR | Конструкторы
FIELD | Поля (включая константы перечислимого типа)
PARAMETER | Параметры методов или конструкторов
LOCAL_VARIABLE | Локальные переменные
TYPE_PARAMETER | Параметры типа
TYPE_USE | Примеры применения типов данных

Таблица 8.4. Правила сохраняемости для мета-аннотации QRetention
Правило сохраняемости | Описание
SOURCE | Аннотации не включаются в файлы классов
CLASS | Аннотации включаются в файлы классов, но виртуальной машине не нужно их загружать
RUNTIME | Аннотации включаются в файлы классов и загружаются виртуальной машиной. Они доступны через прикладной интерфейс API для рефлексии

Допустим, для указания на то, что объекты класса могут сохраняться в базе данных,
определяется наследуемая аннотация @Persistent. В таком случае все подклассы
этого класса будут автоматически аннотироваться как сохраняемые следующим
образом:

@Inherited
@interface Persistent { }

@Persistent
class Employee { . . . }

class Manager extends Employee {...} // также @Persistent

При поиске объектов, сохраняемых в базе данных, механизм сохраняемости будет
обнаруживать как объекты типа Employee, так и объекты типа Manager.

Начиная с версии Java SE 8 допускается неоднократное применение аннотации одного
и того же типа к отдельному элементу. Ради обратной совместимости разработчикам
повторяющейся аннотации пришлось предоставить контейнерную аннотацию, содержащую
повторяющиеся аннотации в массиве.
Ниже показано, каким образом определяются аннотация @TestCase и ее контейнер.

@Repeatable(TestCases.class)
@interface TestCase {
String params();
String expected();
}

@interface TestCases {
TestCase[] value();
}

Всякий раз, когда пользователь предоставляет две или больше аннотации
@TestCase, они автоматически заключаются в оболочку аннотации @TestCases.

Внимание! ====================================================================
Обработка повторяющихся аннотаций требует особого внимания. Если вызвать метод
getAnnotation() для поиска повторяющейся аннотации, которая на самом деле не
повторялась, то и в этом случае может быть получено пустое значение null.
Объясняется это тем, что повторяющиеся аннотации были заключены в оболочку
контейнерной аннотации.
В таком случае следует вызвать метод getAnnotationsByType(), где
просматривается контейнер и предоставляется массив повторяющихся аннотаций.
Если бы имелась только одна аннотация, она была бы получена в массиве единичной
длины. Имея в своем распоряжении данный метод, можно вообще не беспокоиться о
контейнерной аннотации.
==============================================================================

Глава 8 ■ Написание сценариев, компиляция и обработка аннотаций
Обработка аннотаций встроена в компилятор Java. Во время компиляции процессоры
аннотаций можно вызывать по следующей команде:

javac -processor ИмяКлассаПроцессора1, ИмяКлассаПроцессора2, ...
                    Исходные_фаилы
Компилятор обнаруживает аннотации в исходных файлах. Каждый процессор аннотаций
выполняется по очереди с учетом тех аннотаций, к которым он проявил интерес.
Если процессор аннотаций создает новый исходный файл, то данный процесс
повторяется. Как только все исходные файлы будут обработаны, они компилируются.

На заметку! ==================================================================
Процессор аннотаций может только формировать новые исходные файлы и не может
изменять уже имеющиеся исходные файлы!!!!!
==============================================================================

    Процессор аннотаций реализует интерфейс Processor, как правило, расширяя класс
AbstractProcessor. При этом нужно указать, какие именно аннотации поддерживаются
процессором. В данном случае это следующие аннотации:
@SupportedAnnotationTypes("com.horstmann.annotations.ToString")
@SupportedSourceVersion(SourceVersion.RELEASE_8)
public class ToStringAnnotationProcessor extends AbstractProcessor
{
    @Override
    public boolean process(Set<? extends TypeElement> annotations,
                                RoundEnvironment currentRound)
    }
        ...
    }
}

Процессору могут потребоваться конкретные типы аннотаций, метасимволы
подстановки вроде "com.horstmann.*" (т.е. все аннотации из пакета
com.horstmann и любых его подпакетов) или даже "*" (т.е. все аннотации вообще).
Метод process() вызывается один раз на каждом цикле обработки со всеми
аннотациями, обнаруженными в любых файлах в данном цикле, а также со ссылкой
на интерфейс RoundEnvironment, содержащей сведения о текущем цикле обработки.



Уровни в списке выше упорядочены по степени выживания аннотаций
(1 –  самая короткоживущая).

1) Аннотации с RetentionPolicy.SOURCE остаются только в исходниках, в
    скомпилированных файлах их уже нет. Они интересны  либо статическим анализаторам
    кода, либо обработчику аннотаций на этапе компиляции.
    Как создать дополнительный обработчик исходного кода подробно рассматривается в
    это статье {https://sysout.ru/obrabotka-annotatsij-na-urovne-ishodnikov/} – в
    ней мы генерируем новый класс на этапе компиляции. Так работает Lombok – он на
    основе аннотаций генерирует сеттеры и геттеры в исходниках.
2) Аннотации с RetentionPolicy.CLASS остаются в скомпилированных файлах, но на
    этапе выполнения программы в машинном коде их уже нет. Эти аннотации могут
    быть интересны обфускатору кода (который переименовывает и сокращает
    скомпилированный код). Или, например, служебной библиотеке Javassist.
    Как изменить байт-код с помощью этой библиотеки есть в другой статье.
    {https://sysout.ru/modifikatsiya-bajt-koda-s-pomoshhyu-instrumentation/}
3) В этой статье мы рассмотрим, как работать с аннотациями на этапе выполнения
    кода в (runtime), для этого аннотации должны иметь самый сильный уровень
    RetentionPolicy.RUNTIME. Мы будем использовать Java Reflection – библиотеку,
    которая может считать и изменить информацию о классе в процессе выполнения
    программы. А также запустить методы класса.


Класс Class
Теперь пара слов о параметре метода TestRunner.run(Class testClass).

Значит в параметр мы будем передавать объект Class, полученный из класса
Sample1.java

TestRunner.run(Sample1.class);

Библиотека Java Reflection имеет дело с объектом типа Class. Она может получить
из этого объекта список методов, полей, конструкторов, аннотаций для данного
класса.

Объект типа Class создается для каждого класса приложения при его загрузке. То
есть при первом обращении к классу, например при создании объекта этого класса,
загружается скомпилированный .class файл, содержащий байт-код класса,
Sample1.class. Его содержимое загружается в память VM и на его основе в heap
создается объект типа Class<SampleTest>, в котором есть вся информация о классе
– какие в нем методы, поля, конструкторы, аннотации.

Чтобы запустить методы, надо получить их список.
В цикле мы идем по полученным методам класса и выбираем аннотированные.


Собственные аннотации.
Параметры:
@Target
@Retention
*@Target:
  ElementType.ANNOTATION_TYPE - наша аннотация может присутствовать только над
        другими аннотациями и больше нигде (их примеры: @Documented, @Inherited,
  @Target, @Retention)
  ElementType.CONSTRUCTOR - над конструктором и больше нигде
  ElementType.FIELD - над полем класса
  ElementType.LOCAL_VARIABLE - над локальной переменной метода (пример: @NotNull)
  ElementType.METHOD - над методом
  ElementType.PACKAGE - над пакетом (тогда эта аннотация автоматически будет распространяться)
        над всеми классами этого пакета) Например, @Deprecated весь пакет.
  ElementType.PARAMETER - над аргументом метода
  ElementType.TYPE - над классом или над интерфейсом
*@Retention:
  RetentionPolicy.SOURCE - аннотация будет присутствовать только в исходном коде
        и больше нигде (т.е. о ней не будет знать ни компилятор ни runtime.
        используют эту аннотацию в основном только для документации)
  RetentionPolicy.CLASS - аннотация присутствует на время работы компилятора
  RetentionPolicy.RUNTIME - присутствует даже в runtime