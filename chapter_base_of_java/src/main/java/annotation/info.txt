
Аннотации в Java и их обработка в RUNTIME с помощью рефлексии

{https://sysout.ru/annotatsii-v-java-i-ih-obrabotka-v-runtime-s-pomoshhyu-refleksii/}
{https://betacode.net/10197/java-annotation}
{https://github.com/myluckagain/sysout/tree/master/annotations-runtime/src/main/java/ru/sysout/annotationsruntime}

Аннотации – это своего рода маркеры, которые служат знаком либо компилятору,
либо обработчику скомпилированных классов, либо самому приложению во время его
выполнения – знаком что-то сделать.
Аннотации представляют из себя дескрипторы, включаемые в текст программы, и используются
для хранения метаданных программного кода, необходимых на разных этапах жизненного
цикла программы.
Информация, хранимая в аннотациях, может использоваться соответствующими обработчиками
для создания необходимых вспомогательных файлов или для маркировки классов, полей
и т.д.

Для аннотаций всегда нужен обработчик, сами они ничего не делают.

Пример обработчика – тестовый фреймворк JUnit.
Для него мы помечаем метод аннотацией @Test, и он обрабатывает этот метод как
тестовый. Вне фреймворка аннотация  @Test ничего не значит.

Другой пример – ORM-фреймворк Hibernate.  Еще есть Spring Framework,
проект Lombok.

@Target и @Retention – это метаанотации, то есть аннотации, которые применяются
к аннотации.

Значение ElementType.METHOD в @Target показывает, что наша аннотация @Test
применима к методам, то есть с помощью нее можно аннотировать только метод:

@Test
public static void m1() {
}

А вообще аннотации можно применять практически к любому элементу кода – классу,
параметрам, полям…Просто в нашем случае требуется аннотировать только методы,
что мы и указываем в определении аннотации. Если теперь в коде применить
аннотацию @Test к полю, классу или другому элементу, то компилятор выдаст ошибку.

@Retention(RetentionPolicy.RUNTIME) она, как и @Target, доступна в JDK по
умолчанию и служит для оформления пользовательских аннотаций.

Вообще есть три уровня RetentionPolicy:

RetentionPolicy.SOURCE
RetentionPolicy.CLASS (действует по умолчанию, если метааннотация @Retention
не указана)
RetentionPolicy.RUNTIME

“Retention” переводится как “сохранение”, “удержание”, имеется в виду где
(на каком этапе) сохраняются/выживают аннотации.

Уровни в списке выше упорядочены по степени выживания аннотаций
(1 –  самая короткоживущая).

1) Аннотации с RetentionPolicy.SOURCE остаются только в исходниках, в
    скомпилированных файлах их уже нет. Они интересны  либо статическим анализаторам
    кода, либо обработчику аннотаций на этапе компиляции.
    Как создать дополнительный обработчик исходного кода подробно рассматривается в
    это статье {https://sysout.ru/obrabotka-annotatsij-na-urovne-ishodnikov/} – в
    ней мы генерируем новый класс на этапе компиляции. Так работает Lombok – он на
    основе аннотаций генерирует сеттеры и геттеры в исходниках.
2) Аннотации с RetentionPolicy.CLASS остаются в скомпилированных файлах, но на
    этапе выполнения программы в машинном коде их уже нет. Эти аннотации могут
    быть интересны обфускатору кода (который переименовывает и сокращает
    скомпилированный код). Или, например, служебной библиотеке Javassist.
    Как изменить байт-код с помощью этой библиотеки есть в другой статье.
    {https://sysout.ru/modifikatsiya-bajt-koda-s-pomoshhyu-instrumentation/}
3) В этой статье мы рассмотрим, как работать с аннотациями на этапе выполнения
    кода в (runtime), для этого аннотации должны иметь самый сильный уровень
    RetentionPolicy.RUNTIME. Мы будем использовать Java Reflection – библиотеку,
    которая может считать и изменить информацию о классе в процессе выполнения
    программы. А также запустить методы класса.


Класс Class
Теперь пара слов о параметре метода TestRunner.run(Class testClass).

Значит в параметр мы будем передавать объект Class, полученный из класса
Sample1.java

TestRunner.run(Sample1.class);

Библиотека Java Reflection имеет дело с объектом типа Class. Она может получить
из этого объекта список методов, полей, конструкторов, аннотаций для данного
класса.

Объект типа Class создается для каждого класса приложения при его загрузке. То
есть при первом обращении к классу, например при создании объекта этого класса,
загружается скомпилированный .class файл, содержащий байт-код класса,
Sample1.class. Его содержимое загружается в память VM и на его основе в heap
создается объект типа Class<SampleTest>, в котором есть вся информация о классе
– какие в нем методы, поля, конструкторы, аннотации.

Чтобы запустить методы, надо получить их список.
В цикле мы идем по полученным методам класса и выбираем аннотированные.

