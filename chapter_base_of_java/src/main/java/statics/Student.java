package statics;

import java.util.Locale;

/**
 * Часто возникает ситуация, когда нужно задать какой то код, который
 * ГАРАНТИРОВАННО выполниться один единственный раз за всё время работы
 * приложения. И никакой необходимости выполнять этот код еще раз нет
 * необходимости (например конфигурирование логера, создание пула
 * соединений для базы данных либо просто инициализация статических полей).
 * В этом случае прибегают к статическому блоку инициализации.
 * <p>
 * Статический блок будет вызван самым первым, не зависимо где он стоит в коде.
 * Что не может статический блок:
 * - быть вызванным второй раз
 * - не может обращаться к обычным non-static полям класса (в отличие от
 * обычных полей класса, они могут обращаться к статическим полям)
 * - и обращаться к текущему объекту, т.к. он вызывается без объекта
 * Если вдруг в статическом блоке будет выброшен Exception, например
 * деление на ноль, то при запуске программы мы получим ArithmeticException,
 * но он будет завернут в ошибку в блоке инициализации
 * ExceptionInInitializerError.
 * Объясняется это тем, что мы инициализируем в статическом блоке что то
 * уникальное, что можно сделать один раз, а в процессе инициализации
 * происходит ошибка и в дальнейшем приложение рассчитывает на то, что эти
 * данные проинициализированы и хочет ими пользоваться, но они не получили
 * никакого значения и значения по умолчанию у них нет, поэтому VM
 * останавливается с Error и «предлагается» исправить эту ошибку.
 * И было принято такое положение, что если в статическом блоке появляется
 * exception и он ни как не обрабатывается там то он оборачивается в Error,
 * а Error конечно более серьезная вещь, чем Exception.
 * <p>
 * Статические методы не полиморфны, хотя и можно переопределить метод в
 * подклассе, но эффекта не будет.
 * И если метод объявляется статическим, то это значит, что динамический
 * полиморфизм не возможен, для них работает статический полиморфизм,
 * т.е. версия метода класса определяется во время компиляции и изменена
 * во время выполнения не может.
 * Статические методы нельзя переопределять. При их вызове будет
 * использоваться механизм раннего связывания, поэтому будет вызван метод
 * на основе типа ссылочной переменной.
 * Поэтому работая со статическими методами нужно знать, что это некоторая
 * окончательная версия какого то функционала, который никем и никогда
 * подменяться не будет.
 */
public class Student {
    static {
        faculty = "MMF";
    }

    static String faculty;
    private long studentId;
    private String name = "";
    private int yearOfStudy;

    public Student(long studentId) {
        this.studentId = studentId;
    }

    public static void convertFaculty(String head) {
        System.out.println(head + " " + faculty.toLowerCase());
//        System.out.println(head + " " + faculty.toLowerCase(Locale.ROOT));
    }
}
