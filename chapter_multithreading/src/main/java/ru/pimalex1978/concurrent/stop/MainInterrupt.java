package ru.pimalex1978.concurrent.stop;

import java.util.ArrayList;
import java.util.Random;

/*
 * При разработке приложения, очень часто бывает нужно выполнить код в отдельном
 * потоке.
 * В примере рассмотрен поток, который ожидает задачу на выполнение. Ждет и не
 * потребляет ресурсов. Когда получает задачи, то он просыпается и выполняет их.
 * И когда работы нет он снова засыпает. И пересоздавать его каждый раз не нужно.
 * Такие потоки называют worker thread.
 * Поток worker будет работать у нас в бесконечном цикле, будет ждать прихода
 * задач, или когда его не прервут методом interrupt().
 * В данном примере у нас работают два потока: main и worker.
 * main закидывает задачи в очередь, а worker забирает задачи из очереди
 * и запускает их выполнение.
 * И worker и main работают с монитором синхронизации BlockingQueue.
 *
 * Это пример цикла с блокирующей очередью можно найти практически везде:
 * в любом виндовс приложении, андроид приложении.
 * Не смотря на свою простоту, очень часто используется. Это фундаментальные
 * вещи.
 *
 * В этом примере рассматриваем, как остановить поток.
 * Напомню, что просто убить поток нам нельзя worker.stop(), т.к. это может
 * произойти в середине задачи. Чтобы избежать неприятных ситуаций мы
 * сообщаем потоку, что ему нужно остановиться, а поток уже сам решит,
 * когда он может это сделать. Он довелет свои дела до логического конца и
 * безопасно остановится.
 *
 * Для остановки потока будем использовать булевский флажок isInterrupted(),
 * который встроен в каждый поток.
 *
 * Вызов метода interrupt() позволяет не только остановить поток путем установки
 * булевского флага isInterrupted(), но и так же позволяет вывести потоки из
 * заблокированного состояния для того чтобы поток мог завершить свою работу.
 *
 * Особенность использования этого флага и InterruptedException заключается в
 * том, что если где то выбрасывается InterruptedException, то флаг остановки
 * сбрасывается. Т.е. его значение будет false. Чтобы флаг остановки стал
 * true и что бы мы отследили факт остановки, то нужно в месте отлова
 * InterruptedException (в блоке catch) вызвать interrupt() еще раз. Поток
 * сам у себя еще раз перевызывает isInterrupt() для того чтобы установить
 * значение флага в true, чтобы код выше мог отследить, что остановка была.
 *
 * Решение обрабатывать InterruptedException в коде очереди не правильно,
 * потому что решение о том, что делать с этим Exception, должен принимать
 * клиентский код, т.е. код который использует эту очередь. В данном случае
 * нам Exception надо поднять выше. Т.е. добавляем InterruptedException
 * в сигнатуру метода get() класса BlockingQueue. И теперь появится необходимость
 * обработать Exception в коде, который использует очередь, т.е. в
 * клиентском коде. И это более правильно, потому что мы предоставляем
 * пользователю очереди самому решать что делать с этим Exception:
 * или мы его учтем, или отложим, или игнорируем.
 * В нашем случае мы в текущем потоке перевызовем interrupt(). И это
 * более граммотно, т.к. мы не проглатываем InterruptedException, прсото
 * выводя его в консоль e.printStackTrace(), а обрабатываем его, так следует
 * это делать.
 *
 * В клиентском коде InterruptedException всегда нужно обрабатывать должным
 * образом. Если мы поймали внутри InterruptedException, то его нельзя
 * просто проглотить, мы обязаны СИГНАЛИЗИРОВАТЬ вышестоящему коду о том,
 * что это прерывание было, если этого не сделать, то попытки остановить потоки
 * ни к чему не приведут. Поток не остановится. Проглатывая InterruptedException
 * мы лишаем потоки возможности завершиться по нормальному.
 *
 */
public class MainInterrupt {

    public static void main(String[] args) {

        /*создаем объект блокирующей очереди.*/
        BlockingQueue queue = new BlockingQueue();

        /*Создадим поток, который использует блокирующую очередь.
         * Т.е. выполняет задачу.*/
        Thread worker = new Thread(new Runnable() {
            @Override
            public void run() {
                /*поток будет обрабатывать задачи, которые
                 * ему приходят, пока в условии мы не поймаем запрос
                 * на прерывание потока: !Thread.currentThread().isInterrupted()
                 * Задачи это объекты Runnable.
                 * И у Runnable вызываем метод run(). */
                while (!Thread.currentThread().isInterrupted()) {
                    /*Получаем задачу из очереди.*/
                    Runnable task = null;
                    try {
                        task = queue.get();
                        /*выполняем задачу.*/
                        task.run();
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                }
            }
        });

        /*Запускаем поток на выполнение.*/
        worker.start();

        /* Добавим задачи в очередь. Поток будет брать их по одной.
         * После того, как выберет их все, то останеться крутиться в
         * цикле ожидая новых задач.
         * Измени количество циклов на 2, на 5 и увидишь, что программа
         * всё равно будет завершаться через 3 секунды, как будем доходить
         * до worker.interrupt() основного потока main - это правильное
         * завершение работы потоков.
         * */
        for (int i = 0; i < 5; i++) {
            queue.put(getTask());
        }

        /*Пауза в 3 секунды.*/
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        /*Останавливать поток worker будем с помощью булевского флага isInterrupted()*/
        worker.interrupt();
    }


    /* Метод Генератор-задач. Метод создающий объект Runnable.
     * Генерируем Runnable, которые иммитируют какую то работу:
     * показываем задачу, в которой выводится начало работы в задаче,
     * ждем 1 сек, и выводим время окончания выполнения задачи.*/
    private static Runnable getTask() {

        return new Runnable() {
            String name;
            Random random = new Random();

            @Override
            public void run() {
                name = String.valueOf(random.nextInt(100));
                System.out.println("Task started: " + this);
                try {
                    Thread.sleep(1000); //иммитируем какую то деятельность.
                } catch (InterruptedException e) {
//                    e.printStackTrace(); //не будем просто проглатывать InterruptedException

                    /* Перевыставим флаг прерывания для правильной обработки
                     * в дальнейшем. Т.е. еще раз вызовемм Thread.currentThread().interrupt()
                     * */
                    Thread.currentThread().interrupt();
                }
                System.out.println("Task finished: " + this);
            }

            @Override
            public String toString() {
                return name + "[" + super.toString() + "]";
            }
        };
    }

    /*
     * Вспомагательный класс блокирующая очередь. Он нужен чтобы написать
     * worker thread.
     * В ней в ее методах используются методы wait() и notify(), чтобы
     * мы смогли сделать блокирующую очередь.
     *
     * Методы добавления элемента в очередь put() и получения элемента из
     * очереди get() синхронизованны. Монитором синхронизации выступает
     * сам объект блокирующей очереди BlockingQueue.
     * Наша очередь параметризована объектом Runnable.
     * В этой очереди, в ее методах, используются методы wait() и notify(),
     * чтобы мы смогли сделать блокирующую очередь.
     * Метод put() добавляет элементы в очередь. Метод get() получает элементы
     * из очереди, но если очередь пуста, то поток вызвавший этот метод вызывает
     * метод wait(), находящийсяв этом методе get(), и поток блокируется,
     * исполнение останавливается до тех пор пока другой поток не вызовет
     * метод put(), положит элемент в очередь и вызовет метод notify(), который
     * пробудит поток, остановленный на методе wait() и исполнение кода метода
     * get() продолжится.
     */
    static class BlockingQueue {
        /*контейнер для задач, ожидающих выполнение. Т.е. реализуем очередь на ArrayList*/
        ArrayList<Runnable> tasks = new ArrayList<>();

        /*
         * Метод получения задач из очереди.
         * Он синхронизирован. Монитором служит экземпляр очереди
         * BlockingQueue.
         * Метод возвращает задачу из очереди. Но если очередь пустая, то
         * вызывающий поток блокируется методом wait(). Метод wait()
         * освобождает МОНИТОР СИНХРОНИЗАЦИИ, но этот поток блокируется
         * в этом месте до тех пор пока на этом же мониторе другим потоком
         * не будет вызван метод notify(). Метод notify() будет вызван
         * потоком в методе put(). Как только другим потоком, но с захваченным
         * монитором объекта BlockingQueue, будет вызван в методе put()
         * метод notify() и код в методе put() закончится, так сразу
         * будет освобожден монитор. И метод ожидающий в методе wait()
         * захватит снова монитор, то он проснется и сможет продолжить
         * свою работу дальше по коду. И возмет задачу из очереди.
         *
         */
        public synchronized Runnable get() throws InterruptedException {
            /*Пока в очереди ничего нет - ждать.*/
            while (tasks.isEmpty()) {
                wait();
            }
            /*Берем первый элемент из очереди.*/
            Runnable task = tasks.get(0);
            /*Удаляем эту задачу из очереди.*/
            tasks.remove(task);
            /*Возвращаем взятую задачу.*/
            return task;
        }

        /*
         * Метод добавляющий задачи в очередь. Он также синхронизированный.
         * В момент когда вызыватся notify(), поток, заблокированный в
         * методе wait(), метода get() будет разбужен. И когда выполнение
         * кода в методе put() закончится, тогда освободится монитор, и
         * потом поток заблокированный в методе wait() получит этот монитор
         * обратно, и продолжит выполнение кода.
         *
         */
        public synchronized void put(Runnable task) {
            tasks.add(task);
            notify();
        }
    }
}
