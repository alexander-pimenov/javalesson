https://annimon.com/article/3462

*** Что такое CompletableFuture? ***

CompletableFuture используется для асинхронного программирования в Java.
Асинхронное программирование — это средство написания неблокирующего кода путём выполнения задачи в отдельном,
отличном от главного, потоке, а также уведомление главного потока о ходе выполнения, завершении или сбое.

Таким образом, основной поток не блокируется и не ждёт завершения задачи,
а значит может параллельно выполнять и другие задания.

Наличие такого рода параллелизма значительно повышает производительность программ.


*** Future vs CompletableFuture ***

CompletableFuture это расширение Future API, представленного в Java 5.

Future используется как ссылка на результат асинхронной задачи.
В нём есть метод isDone() для проверки, завершилась ли задача или нет,
а также метод get() для получения результата после его завершения.

Future API был хорошим шагом на пути к асинхронному программированию,
но ему не хватало некоторых важных и полезных функций.

*** Ограничения Future ***

1. Его нельзя завершить вручную.
2. Нельзя выполнять дальнейшие действия над результатом Future без блокирования.
    Future не уведомляет о своём завершении. В нём есть метод get(), который блокирует поток до тех пор, пока результат не станет доступным.
    Также в Future нельзя повесить функцию-колбэк, чтобы она срабатывала автоматически, как только станет доступен результат.
3. Невозможно выполнить множество Future один за другим.
4. Невозможно объединить несколько Future.
    Предположим, что у вас есть 10 различных задач во Future, которые вы хотите запустить параллельно,
    и как только все они завершатся, вызвать некоторую функцию. С Future вы не можете сделать и это.
5. Нет обработки исключений.
    Future API не имеет механизма обработки исключений.


CompletableFuture реализует интерфейсы Future и CompletionStage и предоставляет огромный набор удобных
методов для создания и объединения нескольких Future. Он также имеет полноценную поддержку обработки исключений.


*** Создание CompletableFuture ***
*** 1. Простейший пример ***
*** 2. Выполнение асинхронных задач с использованием runAsync() ***
*** 3. Выполнение асинхронной задачи и возврат результата с использованием supplyAsync() ***


===== Заметка о пуле потоков и Executor =====

Вы можете поинтересоваться: хорошо, runAsync() и supplyAsync() выполняются в отдельном потоке,
но мы ведь нигде не создавали новый поток, верно?

Верно! CompletableFuture выполняет эти задачи в потоке,
полученном из глобального ForkJoinPool.commonPool().

Также вы можете создать пул потоков и передать его методам runAsync() и supplyAsync(),
чтобы они выполняли свои задачи в потоке, полученном уже из вашего пула потоков.

Все методы CompletableFuture API представлены в двух вариантах:
один принимает Executor в качестве аргумента, а второй нет.
// Вариации методов runAsync() и supplyAsync()
static CompletableFuture<Void>  runAsync(Runnable runnable)
static CompletableFuture<Void>  runAsync(Runnable runnable, Executor executor)
static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier)
static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier, Executor executor)
=============================================


*** Преобразование действий с CompletableFuture ***
Преобразование действий с CompletableFuture

Метод CompletableFuture.get() блокирующий. Он ждет, пока Future завершится и вернёт результат.

Но это же не то, что нам нужно, верно? Для построения асинхронных систем мы должны иметь
возможность повесить на CompletableFuture колбэк, который автоматически вызовется при завершении Future.

Так что нам не потребуется ждать результат и внутри функции-колбэка мы сможем написать логику,
которая отработает после завершения Future.

Вы можете повесить колбэк на CompletableFuture, используя методы thenApply(), thenAccept() и thenRun().

