Потокобезопасные concurrent коллекции
http://java-online.ru/concurrent-collections.xhtml
http://java-online.ru/concurrent.xhtml

Пакет java.util.concurrent включает несколько потокобезопасных коллекций :

• ConcurrentHashMap	коллекция типа HashMap, реализующая интерфейс ConcurrentMap;
• CopyOnWriteArrayList	коллекция типа ArrayList с алгоритмом CopyOnWrite;
• CopyOnWriteArraySet	реализация интерфейса Set, использующая за основу CopyOnWriteArrayList;
• ConcurrentNavigableMap	расширяет интерфейс NavigableMap;
• ConcurrentSkipListMap	аналог коллекции TreeMap с сортировкой данных по ключу и с поддержкой многопоточности;
• ConcurrentSkipListSet	реализация интерфейса Set, выполненная на основе класса ConcurrentSkipListMap.

На странице представлены только первые три потокобезопасные коллекции. Что касается ConcurrentNavigableMap,
то итераторы этого класса декларируются как потокобезопасные и не вызывают ConcurrentModificationException.
Класс ConcurrentSkipListMap гарантирует усредненную производительность выполнения операций для методов containsKey,
get, put, remove и других подобных.

Представленные на странице примеры использования классов пакета java.util.concurrent связаны с перебором данных и
одновременным внесением изменений в наборы.
Примеры подтверждают неизменность значений при использовании итераторов классов и отсутствие исключений
ConcurrentModificationException.

Упрощённый подход к синхронизации с использованием методов обрамлений имеет существенный недостаток, связанный с
препятствованием масштабируемости, поскольку с коллекцией одновременно может работать только один поток.
Кроме этого, недостаточно обеспечить настоящую потокобезопасность коллекции, если множество распространённых
составных операций всё ещё требуют дополнительной синхронизации. Так простые операции типа get (интерфейс List) и
put (интерфейс Map) могут выполняться безопасно без дополнительной синхронизации. Но существует несколько
распространённых операций, связанных с итератором Iterator<E> и методом add (put-if-absent), которые всё же
нуждаются во внешней синхронизации, чтобы избежать конкуренции при обращении к данным.

Использование методов обрамления для получения синхронизированных коллекций представляет скрытую угрозу, поскольку
разработчики полагают, что, раз коллекции синхронизированы, то они полностью потокобезопасны, и пренебрегают должной
синхронизацией составных операций. Такие программы могут нормально функционировть при лёгкой нагрузке, но при
серьёзной нагрузке они могут вызывать NullPointerException или ConcurrentModificationException.
Это все говориться об общей блокировке об опреаторе synchronized: synchronizedList, synchronizedMap.

Некоторые важные замечания использования synchronized
1. Синхронизация в Java гарантирует, что два потока не могут выполнить синхронизированный метод одновременно.
2. Оператор synchronized можно использовать только с методами и блоками кода, которые могут быть как статическими,
так и не статическими.
3. Если один из потоков начинает выполнять синхронизированный метод или блок, то этот метод/блок блокируются.
Когда поток выходит из синхронизированного метода или блока JVM снимает блокировку. Блокировка снимается, даже
если поток покидает синхронизированный метод после завершения из-за каких-либо ошибок или исключений.
4. Синхронизация в Java вызывает исключение NullPointerException, если объект, используемый в синхронизированном
блоке, не определен, т.е. равен null.
5. Синхронизированные методы в Java вносят дополнительные затраты на производительность приложения. Поэтому
следует использовать синхронизацию, когда она абсолютно необходима.
6. В соответствии со спецификацией языка нельзя использовать synchronized в конструкторе, т.к. приведет к ошибке
компиляции.
### Примечание : ###
для синхронизации потоков можно использовать объекты синхронизации Synchroniser's пакета java.util.concurrent.

Взаимная блокировка
С использованием блокировок необходимо быть очень внимательным, чтобы не создать «взаимоблокировку», которая хорошо
известна разработчикам. Этот термин означает, что один из потоков ждет от другого освобождения заблокированного им
ресурса, в то время как сам также заблокировал один из ресурсов, доступа к которому ждёт второй поток.
В данном процессе могут участвовать два и более потоков.
Взаимная блокировка по другому называется - deadlock.

Основные условия возникновения взаимоблокировок в многопотоковом приложении :

1. наличие ресурсов, которые должны быть доступны только одному потоку в произвольный момент времени;
2. при захвате ресурса поток пытается захватить еще один уникальный ресурс;
3. отсутствует механизм освобождения ресурса при продолжительном его удержании;
4. во время исполнения несколько потоков могут захватить разные уникальные ресурсы и ждать друг от друга их освобождения.


Один из подходов к улучшению масштабируемости коллекции при сохранении потокобезопасности состоит в том, чтобы
обходиться без общей блокировки всей таблицы, а использовать блокировки для каждого hash backet (или, в более
общем случае, пула блокировок, где каждая блокировка защищает несколько бакетов). Это позволяет нескольким потокам
обращаться к различным частям коллекции одновременно, без соперничества за единственную на всю коллекцию блокировку.
Данный подход улучшает масштабируемость операций вставки, извлечения и удаления.

### Класс ConcurrentHashMap ###
Работа обычного HashMap построена на принципах хэширования. Ключ объекта в виде хэш-кода используются в сочетании
с методом equals(), для добавления и поиска элемента в коллекции. Если хэш-код объекта изменить, то в коллекции
объект найти будет практически невозможно. Данный случай ведет к утечке памяти. Чтобы избежать этого ключ и значение
должны быть неизмены. Это является главной причиной того, что неизменяемые классы типа String, Integer и остальные
классы-оболочки подобного типа являются хорошим выбором для создания ключа. Но неизменность для HashMap рекомендована,
и не является обязательной. Если необходимо использовать изменяемый объект, то нужно убедиться в том, что ключевой
хэш-код объекта не меняется. Это может быть сделано путем переопределения метода hashCode. Кроме того ключевые классы
должны работать корректно с методом equals(). Чтобы добавить объект в HashMap необходимо определить хэш-код и найти
правильный сегмент массива hashTable, называемый hash bucket.

Класс ConcurrentHashMap появился в пакете java.util.concurrent в JDK 1.5, является потокобезопасной реализацией Map
и предоставляет намного большую степень масштабирования (параллелизма), чем synchronizedMap. Отличие ConcurrentHashMap
связано с внутренней структурой хранения пар key-value. СoncurrentHashMap использует несколько сегментов, и данный
класс нужно рассматривать как группу HashMap’ов. Количество сегментов по умолчанию равно 16. Если пара key-value
хранится в 10-ом сегменте, то ConcurrentHashMap заблокирует, при необходимости, только 10-й сегмент, и не будет
блокировать остальные 15.

ConcurrentHashMap реализует (implements) интерфейс java.util.concurrent.ConcurrentMap :

public interface ConcurrentMap<K,V> extends Map<K,V>
{
    // добавить, если нет объекта value по ключу K
    V putIfAbsent(K key, V value);

    // удалить, если имеется объект value с ключом K
    boolean remove(K key, V value);

    // заменить oldValue новым newValue объекта с ключом K
    boolean replace(K key, V oldValue, V newValue);

    // заменить новым значением newValue объект с ключом K
    V replace(K key, V newValue);
}

Метод putIfAbsent (K, V) добавляет новую пару key-value только в том случае, если в коллекции нет значения с данным
ключом, и возвращает предыдущее значение для заданного ключа.

Метод remove(K, V) удаляет пару key-value только в том случае, если заданному ключу соответствует значение в
коллекции Map, и возвращает true, если элемент был успешно удален.

Метод replace(K, V, V) заменяет по ключу старое значение на новое только в том случае, если старое значение
соответствует заданному значению, и возвращает true, если значение было заменено на новое.

Метод replace(K, V) заменяет по ключу старое значение на новое, и возвращает предыдущее значение для заданного ключа.

### Класс CopyOnWriteArrayList ###
Класс CopyOnWriteArrayList следует использовать вместо ArrayList в потоконагруженных приложениях, где могут иметь
место нечастые операции вставки и удаления в одних потоках и одновременный перебор в других. Это типично для случая,
когда коллекция ArrayList используется для хранения списка объектов.

При использовании обычной ArrayList в многопоточном приложении необходимо либо блокировать целый список во время
перебора, либо клонировать его перед перебором; оба варианта требуют дополнительных ресурсов. CopyOnWriteArrayList
вместо этого создаёт новую копию списка при выполнении модифицирующей операции и гарантирует, что её итераторы вернут
состояние списка на момент создания итератора и не выкинут ConcurrentModificationException.
Это так называемый алгоритм CopyOnWrite. Нет необходимости клонировать список до перебора или блокировать его во
время перебора, т.к. используемая итератором копия списка изменяться не будет. Другими словами, CopyOnWriteArrayList
содержит изменяемую ссылку на неизменяемый массив, поэтому до тех пор, пока эта ссылка остаётся фиксированной,
вы получаете все преимущества потокобезопасности от неизменности без необходимости блокировок.

Конструкторы класса CopyOnWriteArrayList
Конструкторы CopyOnWriteArrayList с комментариями приведены в следующем листинге.

// создание пустой потокобезопасной коллекции
CopyOnWriteArrayList()

// создание потокобезопасной коллекции с данными list
CopyOnWriteArrayList(Collection<? extends E> list);

// создание потокобезопасной коллекции с копированием данных
CopyOnWriteArrayList(E[] toCopyIn)

### Класс CopyOnWriteArraySet ###
CopyOnWriteArraySet создан на основе класса CopyOnWriteArrayList, т.е. использует все его возможности.
Он добавлен в JDK 1.5 как и остальные коллекции пакета java.util.concurrent. Лучше всего CopyOnWriteArraySet
использовать для read-only коллекций небольших размеров. Если в данных коллекции произойдут изменения, накладные
расходы, связанные с копированием, не должны быть ресурсоёмкими.

Необходимо помнить, что итераторы класса CopyOnWriteArraySet не поддерживают операцию remove(). Попытка удалить элемент
во время итерирации приведет к вызову исключения UnsupportedOperationException. В своей работе итераторы используют
«моментальный снимок» массива, который был сделан на момент создания итератора.

Таким образом, если набор данных небольшой и не подвержен изменениям, то лучше использовать CopyOnWriteArraySet.

Конструкторы класса CopyOnWriteArraySet
// Создание пустого набора данных
CopyOnWriteArraySet()

// Создание набора с элементами коллекции coll
CopyOnWriteArraySet(Collection<? extends E> coll)



