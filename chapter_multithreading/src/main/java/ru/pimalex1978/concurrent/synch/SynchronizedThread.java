package ru.pimalex1978.concurrent.synch;

/**
 * Синхронизация потоков, synchronized.
 * В процессе функционирования потоки часто используют общие ресурсы приложения,
 * определенные вне потока. Если несколько потоков начнут одновременно вносить
 * изменения в общий ресурс, то результаты выполнения программы могут быть
 * непредсказуемыми.
 * <p>
 * В примере определен общий ресурс в виде класса CommonObject, в котором
 * имеется целочисленное поле counter. Данный ресурс используется внутренним
 * классом, создающим поток CounterThread для увеличения в цикле значения
 * counter на единицу. При старте потока полю counter присваивается значение 1.
 * После завершения работы потока значение res.counter должно быть равно 4.
 * <p>
 * Две строчки кода класса CounterThread закомментированы. Посмотри, как работает
 * программа без них, потом убери комментарии и посмотри, какой теперь будет результат.
 * <p>
 * Блокировка на уровне объекта.
 * Блокировать общий ресурс можно на уровне объекта, но нельзя использовать для
 * этих целей примитивные типы. В примере следует удалить строчные комментарии в
 * классе CounterThread, после чего общий ресурс будет блокироваться как только
 * его захватит один из потоков; остальные потоки будут ждать в очереди освобождения
 * ресурса.
 * Результат работы программы при синхронизации доступа к общему ресурсу резко
 * изменится.
 */

class CommonObject {
    int counter = 0;
}

class CounterThread implements Runnable {
    private final CommonObject res;

    CounterThread(CommonObject res) {
        this.res = res;
    }

    /*
     * Попробуйте работу программы с закомментированным
     * и раскомментированным блоком кода.
     *
     * Здесь синхронизируемся по объекту CommonObject res.
     */
    @Override
    public void run() {
//        synchronized (res) { //--место для закомментирования блока
        res.counter = 1;
        for (int i = 1; i < 5; i++) {
            System.out.printf("'%s' - %d\n",
                    Thread.currentThread().getName(),
                    res.counter);
            res.counter++;
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
            }
        }
//        } //--место для закомментирования блока
    }
}

/**
 * В главном классе программы SynchronizedThread.main запускается пять потоков.
 * То есть, каждый поток должен в цикле увеличить значение res.counter с единицы
 * до четырех; и так пять раз. Но результат работы программы, отображаемый в
 * консоли, будет иным.
 * То есть, с общим ресурсом res.counter работают все потоки одновременно,
 * поочередно изменяя значение.
 * Чтобы избежать подобной ситуации, потоки необходимо синхронизировать.
 * Одним из способов синхронизации потоков связан с использованием ключевого
 * слова synchronized. Оператор synchronized позволяет определить блок кода
 * или метод, который должен быть доступен только одному потоку. Можно
 * использовать synchronized в своих классах определяя синхронизированные
 * методы или блоки. Но нельзя использовать synchronized в переменных или
 * атрибутах в определении класса.
 */
public class SynchronizedThread {
    public static void main(String[] args) {
        CommonObject commonObject = new CommonObject();
        for (int i = 10; i < 60; i = i + 10) {
            Thread t = new Thread(new CounterThread(commonObject));
            t.setName("Поток " + i); //Устанавливаем имя потоку.
            t.start();
        }
    }
}
