package ru.pimalex1978.concurrent.queue;

import java.util.ArrayList;

/**
 * Класс блокирующей очереди.
 * Методы добавления элемента в очередь put() и получения элемента из
 * очереди get() синхронизованны. Монитором синхронизации выступает
 * сам объект блокирующей очереди BlockingQueue.
 * Наша очередь параметризована объектом Runnable.
 * В этой очереди, в ее методах, используются методы wait() и notify(),
 * чтобы мы смогли сделать блокирующую очередь.
 * Метод put() добавляет элементы в очередь. Метод get() получает элементы
 * из очереди, но если очередь пуста, то поток вызвавший этот метод вызывает
 * метод wait(), находящийсяв этом методе get(), и поток блокируется,
 * исполнение останавливается до тех пор пока другой поток не вызовет
 * метод put(), положит элемент в очередь и вызовет метод notify(), который
 * пробудит поток, остановленный на методе wait() и исполнение кода метода
 * get() продолжится.
 */
public class BlockingQueue {

    /*контейнер для задач, ожидающих выполнение.*/
    private ArrayList<Runnable> tasks = new ArrayList<>();

    /**
     * Метод добавления элемента в очередь.
     *
     * @param task объект, который будем добавлять в очередь.
     */
    synchronized void put(Runnable task) {
        tasks.add(task);
        notify();
    }

    /**
     * Метод получения элемента из очереди.
     * Пробрасываем InterruptedException в сигнатуре метода,
     * чтобы правильно обрабатывать его в клиентском коде, т.е.
     * в той программе, которая будет использовать очередь.
     */
    synchronized Runnable get() throws InterruptedException {
        /*Пока в очереди ничего нет - ждать.*/
        while (tasks.isEmpty()) {
            wait();
        }
        /*Берем первый элемент из очереди.*/
        Runnable task = tasks.get(0);
        /*Удаляем этот элемент из очереди.*/
        tasks.remove(task);
        /*Возвращаем взятый элемент.*/
        return task;
    }
}
