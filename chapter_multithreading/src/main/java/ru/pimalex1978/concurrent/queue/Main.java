package ru.pimalex1978.concurrent.queue;

import java.util.ArrayList;

/*
 * При разработке приложения, очень часто бывает нужно выполнить код в отдельном
 * потоке.
 * В примере рассмотрен поток, который ожидает задачу на выполнение. Ждет и не
 * потребляет ресурсов. Когда получает задачи, то он просыпается и выполняет их.
 * И когда работы нет он снова засыпает. И пересоздавать его каждый раз не нужно.
 * Такие потоки называют worker thread.
 * Поток worker будет работать у нас в бесконечном цикле, будет ждать прихода
 * задач.
 * В данном примере у нас работают два потока: main и worker.
 * main закидывает задачи в очередь, а worker забирает задачи из очереди
 * и запускает их выполнение.
 * И worker и main работают с монитором синхронизации BlockingQueue.
 *
 * Это пример цикла с блокирующей очередью можно найтипрактически везде:
 * в любом виндовс приложении, андроид приложении.
 * Не смотря на свою простоту, очень часто используется. Это фундаментальные
 * вещи.
 *
 */
public class Main {
    public static void main(String[] args) {

        /*создаем объект блокирующей очереди.*/
        BlockingQueue queue = new BlockingQueue();

        /*Создадим поток, который использует блокирующую очередь.
         * Т.е. выполняет задачу.*/
        Thread worker = new Thread(new Runnable() {
            @Override
            public void run() {
                /*поток будет бесконечно обрабатывать задачи, которые
                 * ему приходят.*/
                while (true) {
                    /*Получаем задачу из очереди.*/
                    Runnable task = queue.get();
                    /*выполняем задачу.*/
                    task.run();
                }
            }
        });
        /*Запускаем поток на выполнение.*/
        worker.start();

        /*Добавим задачи в очередь. Поток будет брать их по одной.
         * После того, как выберет их все, то останеться крутиться в
         * цикле ожидая новых задач.*/
        for (int i = 0; i < 10; i++) {
            queue.put(getTask());
        }
    }

    /* Метод дающий объект Runnable.
     * Показываем задачу, в которой выводится начало работы в задаче, ждем
     * 1 сек, выводим время окончания выполнения задачи.*/
    public static Runnable getTask() {
        return new Runnable() {
            @Override
            public void run() {
                System.out.println("Task started: " + this);
                try {
                    Thread.sleep(1000); //иммитируем какую то деятельность.
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("Task finished: " + this);
            }
        };
    }

    /*
     * Вспомагательный класс блокирующая очередь. Он нужен чтобы написать
     * worker thread.
     *
     *
     */
    static class BlockingQueue {
        /*контейнер для задач, ожидающих выполнение.*/
        ArrayList<Runnable> tasks = new ArrayList<>();

        /*
         * Метод получения задач из очереди.
         * Он синхронизирован. Монитором служит экземпляр очереди
         * BlockingQueue.
         * Метод возвращает задачу из очереди. Но если очередь пустая, то
         * вызывающий поток блокируется методом wait(). Метод wait()
         * освобождает МОНИТОР СИНХРОНИЗАЦИИ, но этот поток блокируется
         * в этом месте до тех пор пока на этом же мониторе другим потоком
         * не будет вызван метод notify(). Метод notify() будет вызван
         * потоком в методе put(). Как только другим потоком, но с захваченным
         * монитором объекта BlockingQueue, будет вызван в методе put()
         * метод notify() и код в методе put() закончится, так сразу
         * будет освобожден монитор. И метод ожидающий в методе wait()
         * захватит снова монитор, то он проснется и сможет продолжить
         * свою работу дальше по коду. И возмет задачу из очереди.
         *
         */
        public synchronized Runnable get() {
            /*Пока в очереди ничего нет - ждать.*/
            while (tasks.isEmpty()) {
                try {
                    wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }

            /*Берем первый элемент из очереди.*/
            Runnable task = tasks.get(0);
            /*Удаляем эту задачу из очереди.*/
            tasks.remove(task);
            /*Возвращаем взятую задачу.*/
            return task;
        }

        /*
         * Метод добавляющий задачи в очередь. Он также синхронизированный.
         * В момент когда вызыватся notify(), поток, заблокированный в
         * методе wait(), метода get() будет разбужен. И когда выполнение
         * кода в методе put() закончится, тогда освободится монитор, и
         * потом поток заблокированный в методе wait() получит этот монитор
         * обратно, и продолжит выполнение кода.
         *
         */
        public synchronized void put(Runnable task) {
            tasks.add(task);
            notify();
        }
    }
}
