package ru.pimalex1978.concurrent.queue;

import java.util.ArrayList;

/*
 * При разработке приложения, очень часто бывает нужно выполнить код в отдельном
 * потоке.
 * В примере рассмотрен поток, который ожидает задачу на выполнение. Ждет и не
 * потребляет ресурсов. Когда получает задачи, то он просыпается и выполняет их.
 * И когда работы нет он снова засыпает. И пересоздавать его каждый раз не нужно.
 * Такие потоки называют worker thread.
 * Поток worker будет работать у нас в бесконечном цикле, будет ждать прихода
 * задач.
 * В данном примере у нас работают два потока: main и worker.
 * main закидывает задачи в очередь, а worker забирает задачи из очереди
 * и запускает их выполнение.
 * И worker и main работают с монитором синхронизации BlockingQueue.
 *
 * Это пример цикла с блокирующей очередью можно найти практически везде:
 * в любом виндовс приложении, андроид приложении.
 * Не смотря на свою простоту, очень часто используется. Это фундаментальные
 * вещи.
 *
 * В этом примере не рассматриваем, как остановить поток.
 *
 */
public class Main {
    public static void main(String[] args) {

        /*создаем объект блокирующей очереди.*/
        BlockingQueue queue = new BlockingQueue();

        /*Создадим поток, который использует блокирующую очередь.
         * Т.е. выполняет задачу.*/
        Thread worker = new Thread(new Runnable() {
            @Override
            public void run() {
                /*поток будет бесконечно обрабатывать задачи, которые
                 * ему приходят. Задачи это объекты Runnable.
                 * И у Runnable вызываем метод run(). */
                while (true) {
                    /*Получаем задачу из очереди.*/
                    Runnable task = queue.get();
                    /*выполняем задачу.*/
                    task.run();
                }
            }
        });
        /*Запускаем поток на выполнение.*/
        worker.start();

        /*Добавим задачи в очередь. Поток будет брать их по одной.
         * После того, как выберет их все, то останеться крутиться в
         * цикле ожидая новых задач.*/
        for (int i = 0; i < 10; i++) {
            queue.put(getTask());
        }
    }

    /* Метод Генератор-задач. Метод создающий объект Runnable.
     * Генерируем Runnable, которые иммитируют какую то работу:
     * показываем задачу, в которой выводится начало работы в задаче,
     * ждем 1 сек, и выводим время окончания выполнения задачи.*/
    public static Runnable getTask() {
        return new Runnable() {
            @Override
            public void run() {
                System.out.println("Task started: " + this);
                try {
                    Thread.sleep(1000); //иммитируем какую то деятельность.
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("Task finished: " + this);
            }
        };
    }

    /*
     * Вспомагательный класс блокирующая очередь. Он нужен чтобы написать
     * worker thread.
     * В ней в ее методах используются методы wait() и notify(), чтобы
     * мы смогли сделать блокирующую очередь.
     *
     * Методы добавления элемента в очередь put() и получения элемента из
     * очереди get() синхронизованны synchronized.
     * Монитором синхронизации выступает сам объект блокирующей
     * очереди BlockingQueue.
     * Наша очередь, вернее контейнер для хранения элементов ArrayList<>
     * параметризована объектом Runnable: ArrayList<Runnable>
     * В этой очереди, в ее методах, используются методы wait() и notify(),
     * чтобы мы смогли сделать блокирующую очередь.
     * Метод put() добавляет элементы в очередь. Метод get() получает элементы
     * из очереди, но если очередь пуста, то поток вызвавший этот метод вызывает
     * метод wait(), находящийсяв этом методе get(), и поток блокируется,
     * исполнение останавливается до тех пор пока другой поток не вызовет
     * метод put(), положит элемент в очередь и вызовет метод notify(), который
     * пробудит поток, остановленный на методе wait(), и исполнение кода метода
     * get() продолжится.
     */

    static class BlockingQueue {
        /*контейнер для задач, ожидающих выполнение. Т.е. реализуем очередь на ArrayList*/
        ArrayList<Runnable> tasks = new ArrayList<>();

        /*
         * Метод получения задач из очереди.
         * Он синхронизирован. Монитором служит экземпляр очереди
         * BlockingQueue.
         * Метод возвращает задачу из очереди. Но если очередь пустая, то
         * вызывающий поток блокируется методом wait(). Метод wait()
         * освобождает МОНИТОР СИНХРОНИЗАЦИИ, но этот поток блокируется
         * в этом месте до тех пор пока на этом же мониторе другим потоком
         * не будет вызван метод notify(). Метод notify() будет вызван
         * потоком в методе put(). Как только другим потоком, но с захваченным
         * монитором объекта BlockingQueue, будет вызван в методе put()
         * метод notify() и код в методе put() закончится, так сразу
         * будет освобожден монитор. И метод ожидающий в методе wait()
         * захватит снова монитор, то он проснется и сможет продолжить
         * свою работу дальше по коду. И возмет задачу из очереди.
         *
         */
        public synchronized Runnable get() {
            /*Пока в очереди ничего нет - ждать.*/
            while (tasks.isEmpty()) {
                try {
                    wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }

            /*Если в очереди что то есть, то берем первый элемент из очереди.*/
            Runnable task = tasks.get(0);
            /*Удаляем эту задачу из очереди.*/
            tasks.remove(task);
            /*Возвращаем взятую задачу.*/
            return task;
        }

        /*
         * Метод добавляющий задачи в очередь. Он также синхронизированный.
         * В момент когда вызыватся notify(), поток, заблокированный в
         * методе wait(), метода get() будет разбужен. И когда выполнение
         * кода в методе put() закончится, тогда освободится монитор, и
         * потом поток заблокированный в методе wait() получит этот монитор
         * обратно, и продолжит выполнение кода.
         *
         */
        public synchronized void put(Runnable task) {
            tasks.add(task);
            notify();
        }
    }
}
