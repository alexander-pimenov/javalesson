# Date in Java
Java Date features


Время в двух координатах:
- UTC (Coordinated Universal Time) - атомные часы, секунда равна какому то эталону.
- GTM (Greenwich Mean Time) - растягивание секунд.

Формат даты:
- ISO 8601
- yyyy-DD-mmTHH:mm:ss+-HH:MM:SS, Zulu - формат времени со сдвигом
- yyyy-DD-mmTHH:mm:ssZ Zulu - формат времени с нулевым сдвигом (аналог записи выше, но без сдвига) - Instant

В Java пошли по пути приведению секунд по GMT. Т.е. `растягивают` секунды. Секунды в Java не равны секундам по атомным часам.
Старый формат GMT поддерживается таким же кодом как для UTC.
Способ парсинга одинаковый.
GMT формат Deprecated, но с программной точки зрения нет разницы с каким форматом мы работаем UTC или GMT.


Moment in timeline:
1) Instant - машинное время, всегда с нулевым сдвигом, т.е. всегда UTC.
    Т.е. это количество миллисекунд от точки отсчета. В этом времени нет никаких сдвигов (Offset), UTC 0.
    Исчисляется в мс. Универсальный формат, который удобно еще и хранить в БД, т.к. драйвера JDBC уже настроены на него
    и не нужно делать дополнительных конвертаций в SqlTimestamp.
2) OffsetDateTime - время, которое позволяет указать текущее время и указать сдвиг. 
    По дефолту OffsetDateTime.now() имеет Clock.systemDefaultZone(). Т.е. сдвиг согласно системы.
    Он не хранит ни какие зоны (но их можно задавать), не знает информацию о световом дне и переводе часов.
    Т.е. это просто текущее по UTC + сдвиг. Этот формат, как и Instant можно хранить в БД. 
   `OffsetDateTime = time-of-day + offset from UTC`
3) ZonedDateTime - это сложный тип, он хранит в себе UTC + ЗОНУ + СДВИГ.
   ZoneId (зона) дает нам набор всех исторических правил (перевод часов, какие-то сдвиги), но сохранять дату в этом формате 
   не стоит, особенно в будущем, потому что выйдут новые правила и дата станет не валидной. 
   _**Best practice** - в этом формате можно время только выводить пользователю, но получать его из другого времени, но НЕ ХРАНИТЬ в этом формате!!!_
   `ZonedDateTime = time-of-day + zonedId + offset from UTC`
4) `Хранить лучше время в Instant или OffsetDateTime.now(ZoneOffset.UTC)!!!` Т.е. храним время с нулевым сдвигом, 
   любое событие, которое хотим записать, приводим к UTC и сохраняем в поле Timestamp в формате UTC.
   Потом, когда нужно время вывести пользователю, мы берем это время и форматируем под конкретного пользователя.
   А чтобы знать как выводить время пользователю, то в настройках пользователя привязать зону и локаль для работы.
   
5) ZoneId - отвечает за конкретные зоны и все и правила по переводу времени, историчность этих переводов (правила сдвига)
   `ZoneId = ZoneOffset + date/time anomalies`  
6) ZoneOffset - подкласс ZoneId, расширяет его.
7) LocalDateTime - не принадлежит определенному идентификатору зоны, только date + time
   Он не относится ни к какой TimeZone, не имеет сдвига. Он дает только дату и время.
   `LocalDateTime = no belongs to specific ZoneId, just date + time`
   Этот тип не предназначен для работы с моментом времени!!!! Т.е. он не знает точного машинного времени,
   т.к. не знает сдвига.
   Он используется, как промежуточный класс для конвертации, 
8) 
    


**Шаблонные буквы для SimpleDateFormat**

Символ	| 	Описание	                                  |	Пример
--- |---------------------------------------------| ---
G	| 		эра (в английской локализации — AD и BC)	 | н.э.
y	| 		год (4-х значное число)		            |	2020
yy	| 	год (последние 2 цифры)		                | 20                                      
yyyy	| 	год (4-х значное число)		            | 2020
M	|		номер месяца (без лидирующих нулей)		| 8
MM	|		номер месяца (с лидирующими нулями, если порядковый номер месяца < 10) |	04
MMM	|		трехбуквенное сокращение месяца (в соответствии с локализацией) |	янв
MMMM	|	полное название месяца					|	Июнь
w	|		неделя в году (без лидирующих нулей)	|	4
ww	|		неделя в году (с лидирующими нулями)	|	04
W	|		неделя в месяце (без лидирующих нулей)	|	3
WW	|		неделя в месяце (с лидирующим нулем)	|	03
D	|		день в году								|	67
d	|		день месяца (без лидирующих нулей)		|	9
dd	|		день месяца (с лидирующими нулями)		|	09
F	|		день недели в месяце (без лидирующих нулей) |	9
FF	|		день недели в месяце (с лидирующими нулями)	| 09
E	|		день недели (сокращение)				|	Вт
EEEE	|	день недели (полностью)					|	пятница
u	|		номер дня недели (без лидирующих нулей)	|	5
uu	|		номер дня недели (с лидирующими нулями)	|	05
a	|		маркер AM/PM							|	AM
H	|		часы в 24-часовом формате без лидирующих нулей |	6
HH	|		часы в 24-часовом формате с лидирующим нулем |	06
k	|		количество часов в 24-часовом формате	|	18
K	|		количество часов в 12-часовом формате	|	6
h	|		время в 12-часовом формате без лидирующих нулей |	6
hh	|		время в 12-часовом формате с лидирующим нулем |	06
m	|		минуты без лидирующих нулей		|			32
mm	|		минуты с лидирующим нулем		|			32
s	|		секунды без лидирующих нулей	|			11
ss	|		секунды с лидирующим нулем		|			11
S	|		миллисекунды					|			297
z	|		часовой пояс					|			EET
Z	|		часовой пояс в формате RFC 822	|			300


Примеры комбинаций символов шаблонов:

Шаблон		|		Пример
--- | ---
dd-MM-YYYY	|		01-11-2020
yyyy-MM-dd	|		2019-10-01
HH:mm:ss.SSS |		23:59.59.999
yyyy-MM-dd HH:mm:ss	| 2018-11-30 03:09:02
yyyy-MM-dd HH:mm:ss.SSS	| 2016-03-01 01:20:47.999
yyyy-MM-dd HH:mm:ss.SSS Z	| 2013-13-13 23:59:59.999 +0100


Таблица старых и новых типов формата времени в Java:

DateTime classes in Java | Legacy                                                                                                                   | Modern
--- |--------------------------------------------------------------------------------------------------------------------------| ---
Moment in UTC | java.util.Date (внутри Date хранится определенное количество миллисекунд), java.sql.Timestamp (для сохранения Date в БД) | java.time.Instatnt (можно использовать его всегда, т.к. он используется и в JDBC драйверах и для сохранения в БД его не нужно конвертировать в SqlTimestamp)
Moment with offset from UTC (сдвиг относительно UTC) | -                                                                                                                        | java.time.OffsetDateTime (он не содержит историю, не станет невалидным в прошлом, поэтому можно так же, как и Instant использовать для хранения в БД)
Moment with timezone | java.util.GregorianCalendar, javax.xml.datatype.XMLGregorianCalendar                                                     | java.time.ZoneDateTime
Date + time-of-day (not a moment) | -                                                                                                                        | java.time.LocalDateTime


- Hibernate 5.2+ начинает native поддерживать java.time (без доп накруток, не нужны никакие доп аннотации)

как правильно писать REST API чтобы нам возвращались правильные данные?


