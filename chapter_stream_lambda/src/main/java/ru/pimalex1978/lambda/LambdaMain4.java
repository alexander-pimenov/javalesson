package ru.pimalex1978.lambda;

import java.util.concurrent.atomic.AtomicInteger;

/*Лямбда-выражения имеют доступ ко всем переменным, которые им «видны» из того
места, где они объявлены. Но лямбда не должна их изменять (присваивать новое
значение).*/
public class LambdaMain4 {
    public static void main(String[] args) {

        // Это не компилируется, т.к.
        // доступ к переменной count осуществляется из внутреннего класса,
        // он должен быть final или фактически final, в любом случае изменять
        // свое значение она не может.
        int count = 0;
        /*Runnable runnable = new Runnable() {
            @Override
            public void run() {
                count++;
            }
        };*/
        /*Тот же принцип используется и в лямбда-выражениях.
        Они имеют доступ ко всем переменным, которые им «видны» из того места,
        где они объявлены. Но лямбда не должна их изменять (присваивать новое значение).*/

        /*Правда, есть вариант обхода этого ограничения в анонимных классах.
        Достаточно лишь создать переменную ссылочного типа и менять внутреннее
        состояние объекта. При этом сама переменная будет указывать на тот же
        объект, и в таком случае можно смело указывать её как final.
        Значение самой переменной во время работы программы не меняется и
        всегда указывает на один и тот же объект, что позволяет нам объявить
        переменную сразу с ключевым словом final.*/
        final AtomicInteger counter1 = new AtomicInteger(0);
        Runnable r1 = new Runnable() {
            @Override
            public void run() {
                counter1.incrementAndGet();
            }
        };

        //Зато вот так тоже — все нормально:
        final AtomicInteger counter2 = new AtomicInteger(0);
        Runnable r2 = () -> counter2.incrementAndGet();


        //Это касается и вызова методов.
        // Изнутри лямбда-выражения можно не только обращаться ко всем
        // «видимым» переменным, но и вызывать те методы, к которым есть доступ.
        //Хотя метод staticMethod() и приватный, но он «доступен» для вызова
        // внутри метода main(), поэтому точно так же доступен для вызова
        // изнутри лямбды, которая создана в методе main.
        Runnable runnable = () -> staticMethod();
        new Thread(runnable).start();


    }

    private static void staticMethod() {
        System.out.println("Я - метод staticMethod(), и меня только-что кто-то вызвал!");
    }
}
