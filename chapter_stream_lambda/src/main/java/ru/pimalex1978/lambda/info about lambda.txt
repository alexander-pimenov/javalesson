-= Суть =-
Лямбда-выражение — это такая функция.
Можете считать, что это обычный метод в Java, только его особенность в том,
что его можно передавать в другие методы в качестве аргумента.

Да, стало возможным передавать в методы не только числа, строки и котиков, но и другие методы!

Мы умеем передавать объекты в методы, мы можем передать тот или иной объект
в метод в зависимости от того, что нам в данный момент надо, и внутри того метода,
куда мы передаем такой объект, будет вызван тот метод, для которого мы написали
реализацию. Возникает вопрос: при чём здесь вообще лямбда-выражения?

При том, что лямбда — это и есть такой объект, который содержит ровно один метод.
Такой себе объект-метод. Метод, запакованный в объект.

Java изначально полностью объектно-ориентированный язык.
За исключением примитивных типов, все в Java – это объекты.
Даже массивы являются объектами. Экземпляры каждого класса – объекты.
Не существует ни единой возможности определить отдельно (вне класса – прим. перев.)
какую-нибудь функцию. И нет никакой возможности передать метод как аргумент
или вернуть тело метода как результат другого метода.
Все так. Но так было до Java 8.

С самого начала, язык Java особо не развивался, если не считать такие вещи как
аннотации (Annotations), дженерики (Generics) и пр. В первую очередь, Java всегда
оставался объектно-ориентированным. После работы с функциональными языками, такими
как JavaScript, можно понять насколько Java строго объектно-ориентирован и строго
типизирован. Функции в Java не нужны. Сами по себе их нельзя встретить в мире Java.

В функциональных языках программирования на первый план выходят функции.
Они существуют сами по себе. Можно присваивать их переменным и передавать через
аргументы другим функциям. JavaScript один из лучших примеров функциональных языков
программирования. На просторах Интернета можно найти хорошие статьи, в которых
детально описаны преимущества JavaScript как функционального языка. Функциональные
языки имеют в своем арсенале такие мощные инструменты как замыкания (Closure),
которые обеспечивают ряд преимуществ над традиционными способами написания
приложений. Замыкание – это функция с привязанной к ней средой — таблицей,
хранящей ссылки на все нелокальные переменные функции. В Java замыкания можно
имитировать через Lambda-выражения. Безусловно между замыканиями и
Lambda-выражениями есть отличия и не малые, но лямбда выражения являются хорошей
альтернативой замыканиям.

Lambda-выражения привносят в Java функциональное звено, которого так давно не хватало.
Lambda-выражения вносят в язык функциональность наравне с объектами.
Хотя это и не на 100 % верно, можно видеть, что Lambda-выражения не являясь
замыканиями предоставляют схожие возможности. В функциональном языке
lambda-выражения – это функции; но в Java, lambda-выражения – представляются
объектами, и должны быть связаны с конкретным объектным типом, который называется
функциональный интерфейс.

Lambda-выражения – это анонимные функции (может и не 100% верное определение для
Java, но зато привносит некоторую ясность).
Проще говоря, это метод без объявления, т.е. без модификаторов доступа,
возвращающие значение и без имени.

Короче говоря, они позволяют написать метод и сразу же использовать его.
Особенно полезно в случае однократного вызова метода, т.к. сокращает время на
объявление и написание метода без необходимости создавать класс.

Поговорим об интерфейсах
В принципе, интерфейс — это просто список абстрактных методов.
Когда мы создаем класс и говорим, что он будет имплементировать какой-то
интерфейс — мы должны в нашем классе написать реализацию тех методов,
которые перечислены в интерфейсе (или, на крайний случай, не писать, но
сделать класс абстрактным).

 Те интерфейсы, у которых только один метод, также называют функциональными интерфейсами.
 В Java 8 они даже помечены специальной аннотацией @FunctionalInterface.

 Именно интерфейсы с одним единственным методом и подходят для использования
 лямбда-выражениями.
 Лямбда-выражение — это метод, завернутый в объект.
 И когда мы передаем куда-то такой объект — мы, по сути, передаем этот один
 единственный метод. Получается, нам не важно, как этот метод называется.
 Все, что нам важно — это параметры, которые этот метод принимает, и,
 собственно, сам код метода.

 Лямбда-выражение — это, по сути реализация функционального интерфейса.
 Где видим интерфейс с одним методом — значит, такой анонимный класс можем
 переписать через лямбду. (Пример, new Thread(new Runnable(){...}))
 Если в интерфейсе больше/меньше одного метода — тогда нам лямбда-выражение
 не подойдет, и будем использовать анонимный класс, или даже обычный.

Где есть в аргументе функциональный интерфейс, там вместо него в main методе (или другом потоке)
можно записать лямбду !!!
Лямбду используем, чтобы в метод (или как пример, в конструктор) передать какую-то логику,
какой-то код. Передать без привязки к какому-либо объекту, т.е. анонимная функция (без названия).
Где нам нужно написать анонимный класс с одним методом (реализация интерфейса с одним методом),
там мы пишем лямбду !!!
Т.е. любые интерфейсы с одним методом, теперь могут быть реализованы прямо на месте
с помощью лямбда-выражений.


 Общий синтаксис примерно такой:
  (параметры) -> {тело метода (логика)}

 Структура Lambda-выражений
 Давайте, изучим структуру lambda-выражений:
 - Lambda-выражения могут иметь от 0 и более входных параметров.
 - Тип параметров можно указывать явно либо может быть получен из контекста.
    Например, (int a) можно записать и так (a)
 - Параметры заключаются в круглые скобки и разделяются запятыми.
    Например (a, b) или (int a, int b) или (String a, int b, float c)
 - Если параметров нет, то нужно использовать пустые круглые скобки.
    Например () -> 42
 - Когда параметр один, если тип не указывается явно, скобки можно опустить.
    Пример: a -> return a*a
 - Тело Lambda-выражения может содержать от 0 и более выражений.
 - Если тело состоит из одного оператора, его можно не заключать в фигурные
    скобки, а возвращаемое значение можно указывать без ключевого слова return.
 - В противном случае фигурные скобки обязательны (блок кода), а в конце надо
    указывать возвращаемое значение с использованием ключевого слова return
    (в противном случае типом возвращаемого значения будет void).

 - Параметры соответствуют тем, что указаны в интерфейсе при описании метода !!!

 - Тело лямбда-выражения - внутри фигурных скобок пишете код, как для
    обычного метода. Если у вас весь код состоит только из одной строки,
    можете вообще фигурных скобок не писать (как и с if-ами, и с циклами) !!!
    Если же ваша лямбда что-то возвращает, но ее тело состоит из одной строки,
    писать return вовсе не обязательно. А вот если у вас фигурные скобки,
    тогда, как, и в обычном методе, нужно явно писать return.

Мы можем использовать лямбда-выражения только в ситуациях, когда компилятор
Java может определить целевой тип:

- Объявления переменных (Variable declarations)

- Задания (Assignments)

- Операторы возврата (Return statements)

- Инициализаторы массива (Array initializers)

- Аргументы метода или конструктора (Method or constructor arguments)

- Тела лямбда-выражений (Lambda expression bodies)

- Условные выражения, ? : (Conditional expressions, ? :)

- Приведение выражений (Cast expressions)


Рассмотрим подробнее момент сохранения лямбда-выражения в переменную.
Runnable runnable = () -> System.out.println("Hello world!");
Интерфейс Runnable нам говорит, что его объекты должны иметь метод
public void run().
()->{}
Согласно интерфейсу, метод run ничего не принимает в качестве параметров.
И ничего не возвращает (void). Поэтому при такой записи будет создан
объект с каким-то методом, который ничего не принимает и не возвращает.
Что вполне соответствует методу run() в интерфейсе Runnable.
Вот почему мы и можем поместить это лямбда-выражение в переменную типа Runnable.

Подобное преобразование всегда осуществляется неявно, когда мы не указываем функциональный интерфейс:
new Thread(
    () -> System.out.println("hello world")
).start();

() -> 42
Снова, ничего не принимает, а возвращает число 42.
Такое лямбда-выражение можно поместить в переменную типа Callable, потому
что в этом интерфейсе определен только один метод, который выглядит примерно так:
V call(),
где V — это тип возвращаемого значения (в нашем случае int).
Callable<Integer> c = () -> 42;

-= Отличие Lambda-выражений от анонимных классов =-
1) Главное отличие состоит в использовании ключевого слова this.
Для анонимных классов ключевое слово ‘this’ обозначает объект анонимного класса,
в то время как в lambda-выражении ‘this’ обозначает объект класса, в котором
lambda-выражение используется.

Использовать эту «фичу» я бы не рекомендовал, поскольку у неё есть побочный эффект
(side effect), что противоречит принципам функционального программирования.
Зато такой подход вполне соответствует ООП. ;)

2) Другое их отличие заключается в способе компиляции. Java компилирует
lambda-выражения с преобразованием их в private-методы класса. При этом
используется инструкция invokedynamic, появившаяся в Java 7 для динамической
привязки метода. Тал Вайс (Tal Weiss) описал в своем блоге как Java
компилирует lambda-выражения в байт-код.

Лямбда-выражения имеют доступ ко всем переменным, которые им «видны» из того
места, где они объявлены. Но лямбда НЕ ДОЛЖНА их изменять (присваивать новое
значение).
Правда, есть вариант обхода этого ограничения в анонимных классах.
Достаточно лишь создать переменную ссылочного типа и менять внутреннее
состояние объекта !!! При этом сама переменная будет указывать на тот же объект,
и в таком случае можно смело указывать её как final !!!

Еще лямбды, в отличие от анонимных классов, нет своей собственной области видимости (scope) !!!
У неё она та, где была создана.

