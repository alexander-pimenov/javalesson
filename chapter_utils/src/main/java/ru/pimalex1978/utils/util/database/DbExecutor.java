package ru.pimalex1978.utils.util.database;

import ru.pimalex1978.utils.util.function.*;
import ru.pimalex1978.utils.util.methods.ConnectionUtils;

import java.sql.*;
import java.util.*;

/**
 * Tool to simplify jdbc queries.
 *
 * @author Petr Arsentev (parsentev@yandex.ru), Aleksei Sapozhnikov (vermucht@gmail.com)
 * @version 0.1
 * @since 0.1
 */
public class DbExecutor implements AutoCloseable {
    /**
     * Database connection.
     */
    private final Connection connection;
    /**
     * Dispatch - fill PreparedStatement parameters.
     */
    private final Map<Class<?>,
            TriConsumerEx<Integer, PreparedStatement, Object>> dFillParameters = new HashMap<>();
    /**
     * Dispatch - get values from ResultSet.
     */
    private final Map<Class<?>,
            BiFunctionEx<Integer, ResultSet, ObjValue>> dGetValues = new HashMap<>();

    /**
     * Constructor.
     *
     * @param connection Connector object.
     */
    public DbExecutor(Connection connection) {
        Connection con = null;
        try {
            con = ConnectionUtils.rollbackOnClose(connection);
        } catch (Exception e) {
            e.printStackTrace();
        }
        this.connection = con;
        this.initFillParamsDispatch();
        this.initGetResultDispatch();
    }

    /**
     * Fills dispatch - fill parameters.
     */
    private void initFillParamsDispatch() {
        this.dFillParameters.put(Integer.class,
                (index, ps, value) -> ps.setInt(index, (Integer) value));
        this.dFillParameters.put(String.class,
                (index, ps, value) -> ps.setString(index, (String) value));
    }

    /**
     * Fills dispatch - get values from ResultSet.
     */
    private void initGetResultDispatch() {
        this.dGetValues.put(String.class,
                ((index, res) -> new ObjValue(res.getString(index + 1))));
        this.dGetValues.put(Integer.class,
                ((index, res) -> new ObjValue(res.getInt(index + 1))));
    }

    /**
     * Sets isolation level for transaction.
     *
     * @param level Isolation level (i.e.: Connection.TRANSACTION_REPEATABLE_READ)
     */
    public void setTransactionIsolation(int level) {
        try {
            this.connection.setTransactionIsolation(level);
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    /**
     * For-each statement with index.
     * Gives value and its index in given list.
     *
     * @param values   List of values.
     * @param consumer Consumer.
     * @param <T>      Values type.
     * @throws Exception Possible Exception.
     */
    private <T> void forIndex(List<T> values, BiConsumerEx<Integer, T> consumer) throws Exception {
        int index = 0;
        for (T value : values) {
            consumer.accept(index++, value);
        }
    }

    /**
     * Wrapper for routine operations with PreparedStatements.
     * Executes sql query and returns result as Optional.
     * <p>
     * This is the basic, full version of execute() method with all input parameters.
     *
     * @param sql               Query string to form PreparedStatement.
     * @param params            List of parameters to put into the PreparedStatement.
     * @param function          Function to execute on the PreparedStatement.
     * @param autoGeneratedKeys A flag indicating whether auto-generated keys should be returned:
     *                          <tt>Statement.RETURN_GENERATED_KEYS</tt> or
     *                          <tt>Statement.NO_GENERATED_KEYS</tt>
     * @param <R>               Return value type.
     * @return Operation result or <tt>Optional.empty</tt>.
     */
    private <R> Optional<R> execute(String sql, List<Object> params,
                                    FunctionEx<PreparedStatement, R> function, int autoGeneratedKeys) {
        Optional<R> result = Optional.empty();
        try (PreparedStatement statement = this.connection.prepareStatement(sql, autoGeneratedKeys)) {
            this.forIndex(params, (index, value) -> this.dFillParameters
                    .get(value.getClass())
                    .accept(index + 1, statement, value));
            result = Optional.of(function.apply(statement));
        } catch (Exception e) {
            e.printStackTrace();
        }
        return result;
    }

    /**
     * Executes sql query and returns result as Optional.
     * Doesn't return auto-generated keys.
     *
     * @param sql      Query string to form PreparedStatement.
     * @param params   List of parameters to put into the PreparedStatement.
     * @param function Function to execute on the PreparedStatement.
     * @param <R>      Return value type.
     * @return Operation result or <tt>Optional.empty</tt>.
     */
    public <R> Optional<R> execute(String sql, List<Object> params,
                                   FunctionEx<PreparedStatement, R> function) {
        return this.execute(sql, params, function, Statement.NO_GENERATED_KEYS);
    }

    /**
     * Executes sql query.
     * Doesn't return any result.
     *
     * @param sql               Query string to form PreparedStatement.
     * @param params            List of parameters to put into the PreparedStatement.
     * @param function          Function to execute on the PreparedStatement.
     * @param autoGeneratedKeys A flag indicating whether auto-generated keys should be returned:
     *                          <tt>Statement.RETURN_GENERATED_KEYS</tt> or
     *                          <tt>Statement.NO_GENERATED_KEYS</tt>
     */
    private void execute(String sql, List<Object> params,
                         ConsumerEx<PreparedStatement> function, int autoGeneratedKeys) {
        this.execute(sql, params, ps -> {
                    function.accept(ps);
                    return Optional.empty();
                }, autoGeneratedKeys
        );
    }

    /**
     * Executes sql query.
     * Doesn't return any result.
     * Doesn't return auto-generated keys.
     *
     * @param sql      Query string to form PreparedStatement.
     * @param params   List of parameters to put into the PreparedStatement.
     * @param function Function to execute on the PreparedStatement.
     */
    private void execute(String sql, List<Object> params,
                         ConsumerEx<PreparedStatement> function) {
        this.execute(sql, params, function, Statement.NO_GENERATED_KEYS);
    }

    /**
     * Wrapper for routine operations with PreparedStatements.
     * Executes sql query.
     * <p>
     * Doesn't take PreparedStatement parameters.
     * Doesn't return any result.
     * Doesn't return auto-generated keys.
     *
     * @param sql      Query string to form PreparedStatement.
     * @param function Function to execute on the PreparedStatement.
     */
    public void execute(String sql, ConsumerEx<PreparedStatement> function) {
        this.execute(sql, Collections.emptyList(), function, Statement.NO_GENERATED_KEYS);
    }

    /**
     * Executes PreparedStatement.executeQuery and returns
     * map with values obtained from ResultSet.
     * <p>
     * Doesn't return auto-generated keys.
     *
     * @param sql     Query string to form PreparedStatement.
     * @param params  List of parameters to put into the PreparedStatement.
     * @param classes List of classes to get from the ResultQuery.
     */
    public Optional<List<Map<Integer, ObjValue>>> executeQuery(String sql, List<Object> params, List<Class<?>> classes) {
        return this.execute(sql, params, (PreparedStatement ps) -> this.getQueryResult(ps, classes));
    }

    /**
     * Executes PreparedStatement.executeQuery and returns
     * map with values obtained from ResultSet.
     * <p>
     * Doesn't take parameters.
     * Doesn't return auto-generated keys.
     *
     * @param sql     Query string to form PreparedStatement.
     * @param classes List of classes to get from the ResultQuery.
     */
    public Optional<List<Map<Integer, ObjValue>>> executeQuery(String sql, List<Class<?>> classes) {
        return this.execute(sql, Collections.emptyList(), (PreparedStatement ps) -> this.getQueryResult(ps, classes));
    }

    /**
     * Gets group result from the PreparedStatement.
     * Returns list of maps, where maps contain entries: (column index) -> (value obtained).
     *
     * @param pStatement Statement used to execute query.
     * @param classes    List of classes to get from the ResultQuery.
     * @return List of maps, where each map represents result row: (column index) -> (value).
     */
    private List<Map<Integer, ObjValue>> getQueryResult(PreparedStatement pStatement, List<Class<?>> classes) {
        List<Map<Integer, ObjValue>> result = new ArrayList<>();
        try (ResultSet res = pStatement.executeQuery()) {
            while (res.next()) {
                Map<Integer, ObjValue> row = new HashMap<>();
                this.forIndex(classes,
                        (index, clazz) -> row.put(index + 1, this.dGetValues.get(clazz).apply(index, res)));
                result.add(row);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return result;
    }

    /**
     * Commits changes to ru.job4j.vacancyparser.database.
     */
    public void commit() {
        try {
            this.connection.commit();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Closes resources. Applied in try-with-resources.
     */
    @Override
    public void close() {
        try {
            this.connection.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Wrapper for value obtained from result set.
     */
    public static class ObjValue {
        /**
         * Value.
         */
        private final Object value;

        /**
         * Constructor. To use only in the executor.
         *
         * @param value Value to assign.
         */
        private ObjValue(Object value) {
            this.value = value;
        }

        /**
         * Returns value as String.
         *
         * @return Value.
         */
        public String asString() {
            if (!(this.value instanceof String)) {
                throw new ClassCastException("Value is not instance of String");
            }
            return (String) this.value;
        }

        /**
         * Returns value as Integer.
         *
         * @return Value.
         */
        public Integer asInteger() {
            if (!(this.value instanceof Integer)) {
                throw new ClassCastException("Value is not instance of Integer");
            }
            return (Integer) this.value;
        }

        /**
         * Equals method.
         *
         * @param o Other object.
         * @return <tt<true</tt> if objects are equal, <tt>false</tt> if not.
         */
        @Override
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (o == null || getClass() != o.getClass()) {
                return false;
            }
            ObjValue objValue = (ObjValue) o;
            return Objects.equals(value, objValue.value);
        }

        /**
         * Returns hash code();
         *
         * @return Integer hashcode.
         */
        @Override
        public int hashCode() {
            return Objects.hash(value);
        }
    }

}