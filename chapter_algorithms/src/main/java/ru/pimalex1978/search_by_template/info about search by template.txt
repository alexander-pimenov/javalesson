http://espressocode.top/naive-algorithm-for-pattern-searching/
http://espressocode.top/kmp-algorithm-for-pattern-searching/

НАИВНЫЙ АЛГОРИТМ ПОИСКА ПО ШАБЛОНУ

Учитывая текст txt [0..n-1] и шаблон pat [0..m-1] , напишите функцию поиска
(char pat [], char txt []), которая печатает все вхождения
pat [] в txt. [] . Вы можете предположить, что n> m .

Примеры:

Input:  txt[] = "THIS IS A TEST TEXT"
        pat[] = "TEST"
Output: Pattern found at index 10

Input:  txt[] =  "AABAACAADAABAABA"
        pat[] =  "AABA"
Output: Pattern found at index 0
        Pattern found at index 9
        Pattern found at index 12


Поиск по шаблону является важной проблемой в информатике. Когда мы ищем строку в
файле блокнота / слова, в браузере или в базе данных, для отображения результатов
поиска используются алгоритмы поиска по шаблону.

Какой самый лучший случай?
Наилучший случай возникает, когда первый символ шаблона вообще отсутствует в тексте.


txt[] = "AABCCAADDEE";

pat[] = "FAA";

Количество сравнений в лучшем случае равно O(n).

Какой наихудший случай?
Наихудший случай поиска наивного шаблона происходит в следующих сценариях.
1) Когда все символы текста и рисунка совпадают.


txt[] = "AAAAAAAAAAAAAAAAAA";

pat[] = "AAAAA";

2) Худший случай также возникает, когда отличается только последний символ.


txt[] = "AAAAAAAAAAAAAAAAAB";

pat[] = "AAAAB";

Количество сравнений в худшем случае равно O(m*(n-m + 1)).
Хотя строки с повторяющимися символами вряд ли появятся в английском тексте,
они вполне могут встречаться в других приложениях (например, в двоичных текстах).
Алгоритм сопоставления KMP улучшает наихудший случай до O(n).

Алгоритм поиска шаблонов Naive не работает должным образом в случаях,
когда мы видим много совпадающих символов, за которыми следует несовпадающий символ.
Ниже приведены некоторые примеры.

   txt[] = "AAAAAAAAAAAAAAAAAB"
   pat[] = "AAAAB"

   txt[] = "ABABABCABABABCABABABC"
   pat[] =  "ABABAC" (not a worst case, but a bad case for Naive)

Алгоритм сопоставления KMP использует вырождающееся свойство
(шаблон, имеющий одни и те же под-шаблоны, появляющиеся в шаблоне более одного раза)
шаблона и улучшающий сложность наихудшего случая до O (n). Основная идея алгоритма
KMP заключается в следующем: всякий раз, когда мы обнаруживаем несоответствие
(после некоторых совпадений), мы уже знаем некоторые символы в тексте следующего окна.
Мы используем эту информацию, чтобы избежать совпадения символов, которые, как мы знаем,
будут совпадать. Давайте рассмотрим пример ниже, чтобы понять это.

Matching Overview
txt = "AAAAABAAABA"
pat = "AAAA"

We compare first window of txt with pat
txt = "AAAAABAAABA"
pat = "AAAA"  [Initial position]
We find a match. This is same as Naive String Matching.

In the next step, we compare next window of txt with pat.
txt = "AAAAABAAABA"
pat =  "AAAA" [Pattern shifted one position]
Именно здесь KMP проводит оптимизацию по сравнению с Naive.
Во втором окне мы сравниваем только четвертую букву А с четвертым символом
текущего окна текста, чтобы определить, совпадает ли текущее окно или нет.
Поскольку мы знаем, что первые три символа все равно будут совпадать, мы
пропустили соответствие первых трех символов.

Нужна предварительная обработка?
Важный вопрос возникает из приведенного выше объяснения,
как узнать, сколько символов нужно пропустить. Чтобы знать это,
мы предварительно обрабатываем шаблон и готовим целочисленный массив
lps [], который сообщает количество пропущенных символов.

Обзор предварительной обработки:

Алгоритм KMP предварительно обрабатывает pat [] и создает вспомогательный lps []
размером m (такой же, как размер шаблона), который используется для пропуска символов
при сопоставлении.
Имя lps указывает самый длинный правильный префикс, который также является суффиксом. ,
Правильный префикс — префикс с недопустимой строкой. Например, префиксами «ABC»
являются «», «A», «AB» и «ABC». Правильные префиксы: «», «A» и «AB».
Суффиксами строки являются «», «C», «BC» и «ABC».
Мы ищем lps в под-шаблонах. Более четко мы сфокусируемся на подстроках шаблонов,
которые имеют префикс или суффикс.
Для каждого подшаблона pat [0..i], где i = 0 до m-1, lps [i] хранит длину
максимального соответствующего собственного префикса, который также является
суффиксом подшаблона pat [0..i] ,
   lps[i] = самый длинный правильный префикс pat[0..i]
              который также является суффиксом pat[0..i].
Примечание:
lps [i] также может быть определен как самый длинный префикс, который также
является правильным суффиксом.
Нам нужно правильно использовать в одном месте, чтобы убедиться, что вся
подстрока не рассматривается.

Examples of lps[] construction:
For the pattern “AAAA”,
lps[] is [0, 1, 2, 3]

For the pattern “ABCDE”,
lps[] is [0, 0, 0, 0, 0]

For the pattern “AABAACAABAA”,
lps[] is [0, 1, 0, 1, 2, 0, 1, 2, 3, 4, 5]

For the pattern “AAACAAAAAC”,
lps[] is [0, 1, 2, 0, 1, 2, 3, 3, 3, 4]

For the pattern “AAABAAA”,
lps[] is [0, 1, 2, 0, 1, 2, 3]
Алгоритм поиска:
В отличие от наивного алгоритма , где мы скользим по шаблону по одному и
сравниваем все символы в каждой смене, мы используем значение из lps [],
чтобы определить, какие из следующих символов должны быть сопоставлены.
Идея состоит в том, чтобы не соответствовать персонажу, который, как мы знаем,
в любом случае будет соответствовать.

Как использовать lps [] для определения следующих позиций
(или для определения количества пропускаемых символов)?

Мы начинаем сравнение pat [j] с j = 0 с символами текущего окна текста.
Мы сохраняем совпадающие символы txt [i] и pat [j] и продолжаем увеличивать
i и j, в то время как pat [j] и txt [i] продолжают совпадать .
Когда мы видим несоответствие
Мы знаем, что символы pat [0..j-1] совпадают с txt [ij… i-1]
(обратите внимание, что j начинается с 0 и увеличивает его только в случае совпадения).
Мы также знаем (из приведенного выше определения), что lps [j-1] — это число
символов pat [0… j-1], которые являются как собственным префиксом, так и суффиксом.
Из вышеупомянутых двух пунктов мы можем заключить, что нам не нужно сопоставлять
эти символы lps [j-1] с txt [ij… i-1], потому что мы знаем, что эти символы в
любом случае будут совпадать. Давайте рассмотрим приведенный выше пример,
чтобы понять это.
txt[] = "AAAAABAAABA"
pat[] = "AAAA"
lps[] = {0, 1, 2, 3}

i = 0, j = 0
txt[] = "AAAAABAAABA"
pat[] = "AAAA"
txt[i] and pat[j] match, do i++, j++

i = 1, j = 1
txt[] = "AAAAABAAABA"
pat[] = "AAAA"
txt[i] and pat[j] match, do i++, j++

i = 2, j = 2
txt[] = "AAAAABAAABA"
pat[] = "AAAA"
pat[i] and pat[j] match, do i++, j++

i = 3, j = 3
txt[] = "AAAAABAAABA"
pat[] = "AAAA"
txt[i] and pat[j] match, do i++, j++

i = 4, j = 4
Since j == M, print pattern found and reset j,
j = lps[j-1] = lps[3] = 3

Here unlike Naive algorithm, we do not match first three
characters of this window. Value of lps[j-1] (in above
step) gave us index of next character to match.
i = 4, j = 3
txt[] = "AAAAABAAABA"
pat[] =  "AAAA"
txt[i] and pat[j] match, do i++, j++

i = 5, j = 4
Since j == M, print pattern found and reset j,
j = lps[j-1] = lps[3] = 3

Again unlike Naive algorithm, we do not match first three
characters of this window. Value of lps[j-1] (in above
step) gave us index of next character to match.
i = 5, j = 3
txt[] = "AAAAABAAABA"
pat[] =   "AAAA"
txt[i] and pat[j] do NOT match and j > 0, change only j
j = lps[j-1] = lps[2] = 2

i = 5, j = 2
txt[] = "AAAAABAAABA"
pat[] =    "AAAA"
txt[i] and pat[j] do NOT match and j > 0, change only j
j = lps[j-1] = lps[1] = 1

i = 5, j = 1
txt[] = "AAAAABAAABA"
pat[] =     "AAAA"
txt[i] and pat[j] do NOT match and j > 0, change only j
j = lps[j-1] = lps[0] = 0

i = 5, j = 0
txt[] = "AAAAABAAABA"
pat[] =      "AAAA"
txt[i] and pat[j] do NOT match and j is 0, we do i++.

i = 6, j = 0
txt[] = "AAAAABAAABA"
pat[] =       "AAAA"
txt[i] and pat[j] match, do i++ and j++

i = 7, j = 1
txt[] = "AAAAABAAABA"
pat[] =       "AAAA"
txt[i] and pat[j] match, do i++ and j++

We continue this way...