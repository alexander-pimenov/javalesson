package ru.pimalex1978.binary_search;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

/**
 * https://stepik.org/lesson/16969/step/1?unit=4500
 * Практика на Java: Двоичный поиск
 * В файле, из которого вычитываем информацию первое число это сколько
 * чисел в массиве, потом столько же разных чисел, а во второй строчке
 * первое число - это сколько чисел ищем и затем, какое это число.
 * Например:
 * 5 1 5 8 12 13 - 5 - количество чисел в массиве, дальше сами числа - 1 5 8 12 13
 * 5 8 1 23 1 11 - 5 - количество чисел, которые ищем, дальше какие это числа - 8 1 23 1 11
 * На выход получим индексы чисел, которые ищем, если они нашлись и -1 если не нашлись.
 * Интересная особенность,
 * чтобы искал самое первое включение из одинаковых чисел. Т.е. более общий случай
 * для двоичного поиска.
 * <p>
 * Плюс двоичного поиска в том, что если мы ищем такой элемент, которого нет в
 * массиве, то он может найти то место которое бы занимал элемент который мы
 * ищем (нужно немного поправить код)
 */
public class BinarySearchAndHash {
    public static void main(String[] args) throws FileNotFoundException {
        long startTime = System.currentTimeMillis();
        new BinarySearchAndHash().run();
        long finishTime = System.currentTimeMillis();
        System.out.println(finishTime - startTime + " ms");
    }

    private void run() throws FileNotFoundException {
        //читаем данные из входного файла, либо тот который в папке resources
        //либо сгенерированный, лежащий в корне программы
        //используем Scanner
        //читаем из сгенерированного файла
        Scanner input = new Scanner(new File("inputBinarySearch.txt")); //читаем из самописного файла
        //читаем из самописного файла:
//        Scanner input = new Scanner(new File(BinarySearch.class.getResource("/inputBinarySearch.txt").getFile())); //resources
//        Scanner input = new Scanner(new File(BinarySearchAndHash.class.getResource("/inputBinarySearchManySameNumbers.txt").getFile())); //resources

        //сначала читаем число чисел
        int n = input.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = input.nextInt();
        }
        int k = input.nextInt();
        int[] b = new int[k];
        for (int i = 0; i < k; i++) {
            b[i] = input.nextInt();
        }

        //положим все элементы в хэш-таблицу
        Map<Integer, Integer> positions = new HashMap<>();
        for (int i = 0; i < n; i++) {
            // ключ=число : значение=его позиция
            positions.put(a[i], i + 1);
        }

        /*Используем поиск заложенный в HashMap или двоичный поиск,
         * чтобы посмотреть за какое время они работают*/
        for (int i = 0; i < k; i++) {
//            int pos = binarySearch1(a, b[i]);
            int pos = positions.containsKey(b[i]) ? positions.get(b[i]) : -1;
            System.out.print(pos + " ");
        }
        System.out.println();
    }

    /**
     * Метод Бинарного поиска элемента в массиве.
     * Поиск производим только в отсортированном массиве!
     * <p>
     * Этот алгоритм работает в 5 раз быстрее линейного linearSearch поиска.
     * <p>
     * Если в отсортированном массиве встречается подряд много одинаковых
     * чисел, например, массив из 10 элементов [1,2,3,3,3,3,3,3,4,5], и мы будем
     * искать элемент 3, то нам выведена будет 3, которая стоит посередине.
     *
     * @param a массив, в котором ищем
     * @param x элемент, который хотим найти
     * @return индекс найденного элемента или -1 при отрицательном поиске
     */
    private int binarySearch1(int[] a, int x) {
        //ищем элемент в границах от l до r
        int l = 0;
        int r = a.length - 1;
        //пока в отрезке есть хоть один элемент, пытаемся его найти
        while (r >= l) {
            int m = (l + r) >> 1; //берем средний элемент m=(l+r)>>1 (сдвиг вправо) => (l + r) / 2
            //проверим элемент с индексом m на равенство x
            if (a[m] == x) {
                //если найдем, то вернем индекс (установим нумерацию с 1)
                return (m + 1);
            } else if (a[m] > x) {
                //то ищем левее
                r = m - 1;
            } else {
                //то ищем правее
                l = m + 1;
            }
        }
        //если ничего не нашли
        return -1;
    }

    /**
     * Метод Бинарного поиска элемента в массиве.
     * Поиск производим только в отсортированном массиве!
     * <p>
     * Этот алгоритм работает в 5 раз быстрее линейного linearSearch поиска.
     * <p>
     * Если в отсортированном массиве встречается подряд много одинаковых
     * чисел, например, массив из 10 элементов [1,2,3,3,3,3,3,3,4,5], и мы будем
     * искать элемент 3, то нам выведена будет первая встречающаяся 3.
     *
     * @param a массив, в котором ищем
     * @param x элемент, который хотим найти
     * @return индекс найденного элемента или -1 при отрицательном поиске
     */
    private int binarySearch2(int[] a, int x) {
        //ищем элемент в границах от l до r, но границы установим как бы на один шаг
        //левее (не 0, а -1) и правее (не a.length-1, а a.length)
        int l = -1;
        int r = a.length;
        /*Будем поддерживать такой инвариант:
         * a[l] < x, a[r] >= x*/
        //пока в отрезке есть хоть один элемент, пытаемся его найти
        //и движемся навстречу друг другу, пока
        while (r > (l + 1)) {
            int m = (l + r) >> 1; //берем средний элемент m=(l+r)>>1 (сдвиг вправо) => (l + r) / 2
            //проверим элемент с индексом m на соответствие x
            if (a[m] < x) {
                //чтобы инвариант не испортился, то меняем местами
                l = m;
            } else {
                //иначе, переставляем правую границу
                r = m;
            }
        }
        if (r < a.length && a[r] == x) {
            return (r + 1); //индексируем с 1
        } else {
            //если ничего не нашли
            return -1;
        }
    }

    /**
     * Метод Бинарного поиска элемента в массиве.
     * Поиск производим только в отсортированном массиве!
     * <p>
     * Этот алгоритм работает в 5 раз быстрее линейного linearSearch поиска.
     * <p>
     * Если в отсортированном массиве встречается подряд много одинаковых
     * чисел, например, массив из 10 элементов [1,2,3,3,3,3,3,3,4,5], и мы будем
     * искать элемент 3, то нам выведена будет последняя встречающаяся 3.
     *
     * @param a массив, в котором ищем
     * @param x элемент, который хотим найти
     * @return индекс найденного элемента или -1 при отрицательном поиске
     */
    private int binarySearch3(int[] a, int x) {
        //ищем элемент в границах от l до r, но границы установим как бы на один шаг
        //левее (не 0, а -1) и правее (не a.length-1, а a.length)
        int l = -1;
        int r = a.length;
        /*Будем поддерживать такой инвариант:
         * a[l] <= x, a[r] > x*/
        //пока в отрезке есть хоть один элемент, пытаемся его найти
        //и движемся навстречу друг другу, пока
        while (r > (l + 1)) {
            int m = (l + r) >> 1; //берем средний элемент m=(l+r)>>1 (сдвиг вправо) => (l + r) / 2
            //проверим элемент с индексом m на соответствие x
            if (a[m] <= x) {
                //чтобы инвариант не испортился, то меняем местами
                l = m;
            } else {
                //иначе, переставляем правую границу
                r = m;
            }
        }
        //проверка, что l-й элемент существует и при этом этот l-q элемент
        //равен x
        if (l >= 0 && a[l] == x) {
            return (l + 1); //индексируем с 1
        } else {
            //если ничего не нашли
            return -1;
        }
    }
}
