package ru.pimalex1978.binary_search;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

/**
 * https://stepik.org/lesson/16969/step/1?unit=4500
 * Практика на Java: Двоичный поиск
 * В файле, из которого вычитываем информацию первое число это сколько
 * чисел в массиве, потом столько же разных чисел, а во второй строчке
 * первое число - это сколько чисел ищем и затем, какое это число.
 * Например:
 * 5 1 5 8 12 13 - 5 - количество чисел в массиве, дальше сами числа - 1 5 8 12 13
 * 5 8 1 23 1 11 - 5 - количество чисел, которые ищем, дальше какие это числа - 8 1 23 1 11
 * На выход получим индексы чисел, которые ищем, если они нашлись и -1 если не нашлись.
 * Интересная особенность,
 * чтобы искал самое первое включение из одинаковых чисел. Т.е. более общий случай
 * для двоичного поиска.
 */
public class BinarySearch {
    public static void main(String[] args) throws FileNotFoundException {
        long startTime = System.currentTimeMillis();
        new BinarySearch().run();
        long finishTime = System.currentTimeMillis();
        System.out.println(finishTime - startTime + " ms");
    }

    private void run() throws FileNotFoundException {
        //читаем данные из входного файла, либо тот который в папке resources
        //либо сгенерированный, лежащий в корне программы
        //используем Scanner

        //читаем из сгенерированного файла
//        Scanner input = new Scanner(new File("inputBinarySearch.txt")); //читаем из самописного файла //for binarySearch1(), binarySearch2(), binarySearch3()

        //читаем из самописного файла:
//        Scanner input = new Scanner(new File(BinarySearch.class.getResource("/inputBinarySearch.txt").getFile())); //for binarySearch1(), binarySearch2(), binarySearch3()
//        Scanner input = new Scanner(new File(BinarySearch.class.getResource("/inputBinarySearchManySameNumbers.txt").getFile())); //for binarySearch1(), binarySearch2(), binarySearch3()
        Scanner input = new Scanner(new File(BinarySearch.class.getResource("/inputBinarySearchWithoutNumber.txt").getFile())); //for //for binarySearch1(), binarySearch2(), binarySearch3(), binarySearch4()

        //сначала читаем число чисел
        int n = input.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = input.nextInt();
        }
        int k = input.nextInt();
        int[] b = new int[k];
        for (int i = 0; i < k; i++) {
            b[i] = input.nextInt();
        }

        /*Используем или линейный поиск (выбирай)*/
//        for (int i = 0; i < k; i++) {
//            int pos = linearSearch(a, b[i]);
//            System.out.print(pos + " ");
//        }
//        System.out.println();

        /*Используем или бинарный поиск (выбирай)*/
        for (int i = 0; i < k; i++) {
            /*выбирай вариант: 1 || 2 || 3 || 4*/
//            int pos = binarySearch1(a, b[i]); //#1
//            int pos = binarySearch2(a, b[i]); //#2
//            int pos = binarySearch3(a, b[i]); //#3
            int pos = binarySearch4(a, b[i]); //#4
            System.out.print(pos + " ");
        }
        System.out.println();
    }

    /**
     * Метод Линейного поиска элемента в массиве.
     * С его помощью можно искать в неотсортированных массивах.
     *
     * @param a массив, в котором ищем
     * @param x элемент, который хотим найти
     * @return индекс найденного элемента или -1 при отрицательном поиске
     */
    private int linearSearch(int[] a, int x) {
        for (int i = 0; i < a.length; i++) {
            if (a[i] == x) return (i + 1); //вернем индекс
        }
        return -1;
    }

    /**
     * Метод Бинарного поиска элемента в массиве.
     * Поиск производим только в отсортированном массиве!
     * <p>
     * Этот алгоритм работает в 5 раз быстрее линейного linearSearch поиска.
     * <p>
     * Если в отсортированном массиве встречается подряд много одинаковых
     * чисел, например, массив из 10 элементов [1,2,3,3,3,3,3,3,4,5], и мы будем
     * искать элемент 3, то нам выведена будет 3, которая стоит посередине.
     *
     * @param a массив, в котором ищем
     * @param x элемент, который хотим найти
     * @return индекс найденного элемента или -1 при отрицательном поиске
     */
    private int binarySearch1(int[] a, int x) {
        //ищем элемент в границах от l до r
        int l = 0;
        int r = a.length - 1;
        //пока в отрезке есть хоть один элемент, пытаемся его найти
        while (r >= l) {
            int m = (l + r) >> 1; //берем средний элемент m=(l+r)>>1 (сдвиг вправо) => (l + r) / 2
            //проверим элемент с индексом m на равенство x
            if (a[m] == x) {
                //если найдем, то вернем индекс (установим нумерацию с 1)
                return (m + 1);
            } else if (a[m] > x) {
                //то ищем левее
                r = m - 1;
            } else {
                //то ищем правее
                l = m + 1;
            }
        }
        //если ничего не нашли
        return -1;
    }

    /**
     * Метод Бинарного поиска элемента в массиве.
     * Поиск производим только в отсортированном массиве!
     * <p>
     * Этот алгоритм работает в 5 раз быстрее линейного linearSearch поиска.
     * <p>
     * Если в отсортированном массиве встречается подряд много одинаковых
     * чисел, например, массив из 10 элементов [1,2,3,3,3,3,3,3,4,5], и мы будем
     * искать элемент 3, то нам выведена будет первая встречающаяся 3.
     *
     * @param a массив, в котором ищем
     * @param x элемент, который хотим найти
     * @return индекс найденного элемента или -1 при отрицательном поиске
     */
    private int binarySearch2(int[] a, int x) {
        //ищем элемент в границах от l до r, но границы установим как бы на один шаг
        //левее (не 0, а -1) и правее (не a.length-1, а a.length)
        int l = -1;
        int r = a.length;
        /*Будем поддерживать такой инвариант:
         * a[l] < x, a[r] >= x*/
        //пока в отрезке есть хоть один элемент, пытаемся его найти
        //и движемся навстречу друг другу, пока
        while (r > (l + 1)) {
            int m = (l + r) >> 1; //берем средний элемент m=(l+r)>>1 (сдвиг вправо) => (l + r) / 2
            //проверим элемент с индексом m на соответствие x
            if (a[m] < x) {
                //чтобы инвариант не испортился, то меняем местами
                l = m;
            } else {
                //иначе, переставляем правую границу
                r = m;
            }
        }
        if (r < a.length && a[r] == x) {
            return (r + 1); //индексируем с 1
        } else {
            //если ничего не нашли
            return -1;
        }
    }

    /**
     * Метод Бинарного поиска элемента в массиве.
     * Поиск производим только в отсортированном массиве!
     * <p>
     * Этот алгоритм работает в 5 раз быстрее линейного linearSearch поиска.
     * <p>
     * Если в отсортированном массиве встречается подряд много одинаковых
     * чисел, например, массив из 10 элементов [1,2,3,3,3,3,3,3,4,5], и мы будем
     * искать элемент 3, то нам выведена будет последняя встречающаяся 3.
     *
     * @param a массив, в котором ищем
     * @param x элемент, который хотим найти
     * @return индекс найденного элемента или -1 при отрицательном поиске
     */
    private int binarySearch3(int[] a, int x) {
        //ищем элемент в границах от l до r, но границы установим как бы на один шаг
        //левее (не 0, а -1) и правее (не a.length-1, а a.length)
        int l = -1;
        int r = a.length;
        /*Будем поддерживать такой инвариант:
         * a[l] <= x, a[r] > x*/
        //пока в отрезке есть хоть один элемент, пытаемся его найти
        //и движемся навстречу друг другу, пока
        while (r > (l + 1)) {
            int m = (l + r) >> 1; //берем средний элемент m=(l+r)>>1 (сдвиг вправо) => (l + r) / 2
            //проверим элемент с индексом m на соответствие x
            if (a[m] <= x) {
                //чтобы инвариант не испортился, то меняем местами
                l = m;
            } else {
                //иначе, переставляем правую границу
                r = m;
            }
        }
        //проверка, что l-й элемент существует и при этом этот l-q элемент
        //равен x
        if (l >= 0 && a[l] == x) {
            return (l + 1); //индексируем с 1
        } else {
            //если ничего не нашли
            return -1;
        }
    }

    /**
     * Метод Бинарного поиска элемента в массиве.
     * Поиск производим только в отсортированном массиве!
     * <p>
     * Этот алгоритм работает в 5 раз быстрее линейного linearSearch поиска.
     * <p>
     * Если в отсортированном массиве нет числа, которое ищем, например,
     * массив из 10 элементов [1,2,3,3,3,3,3,3,5,6], и мы будем
     * искать элемент 4, то нам выведена будет позиция, на которой этот
     * элемент стоял бы. В этом примере выводит 8.
     * <p>
     * Такой метод тоже иногда может быть полезен.
     *
     * @param a массив, в котором ищем
     * @param x элемент, который хотим найти
     * @return индекс найденного элемента или его предполагаемый индекс при отрицательном поиске
     */
    private int binarySearch4(int[] a, int x) {
        //ищем элемент в границах от l до r, но границы установим как бы на один шаг
        //левее (не 0, а -1) и правее (не a.length-1, а a.length)
        int l = -1;
        int r = a.length;
        /*Будем поддерживать такой инвариант:
         * a[l] <= x, a[r] > x*/
        //пока в отрезке есть хоть один элемент, пытаемся его найти
        //и движемся навстречу друг другу, пока
        while (r > (l + 1)) {
            int m = (l + r) >> 1; //берем средний элемент m=(l+r)>>1 (сдвиг вправо) => (l + r) / 2
            //проверим элемент с индексом m на соответствие x
            if (a[m] <= x) {
                //чтобы инвариант не испортился, то меняем местами
                l = m;
            } else {
                //иначе, переставляем правую границу
                r = m;
            }
        }
        return (l + 1); //индексируем с 1
    }
}

