Что такое эта рефлексия? Существует короткое и точное, а также популярное на просторах интернета определение.
https://javarush.ru/groups/posts/513-reflection-api-refleksija-temnaja-storona-java

Рефлексия (от позднелат. reflexio — обращение назад) — это механизм исследования данных о программе во время
её выполнения. Рефлексия позволяет исследовать информацию о полях, методах и конструкторах классов.

Сам же механизм рефлексии позволяет обрабатывать типы, отсутствующие при компиляции, но появившиеся во время
выполнения программы. Рефлексия и наличие логически целостной модели выдачи информации об ошибках дает
возможность создавать корректный динамический код.

Вот основной список того, что позволяет рефлексия:
Узнать/определить класс объекта;
1. Получить информацию о модификаторах класса, полях, методах, константах, конструкторах и суперклассах;
2. Выяснить, какие методы принадлежат реализуемому интерфейсу/интерфейсам;
3. Создать экземпляр класса, причем имя класса неизвестно до момента выполнения программы;
4. Получить и установить значение поля объекта по имени;
5. Вызвать метод объекта по имени.

В java есть замечательный класс Class. Он представляет классы и интерфейсы в исполняемом приложении Java.
Связь между Class и ClassLoader мы затрагивать не будем, т.к. это не есть тема статьи.

Далее, чтобы получить поля этого класса нужно вызвать метод getFields(), этот метод вернет нам все доступные поля
класса. Нам это не подходит, так как наше поле private, поэтому используем метод getDeclaredFields(), этот метод
также возвращает массив полей класса, но теперь и private и protected.
В нашей ситуации мы знаем имя поля, которое нас интересует, и можем использовать метод getDeclaredField(String),
где String — имя нужного поля.

Примечание: getFields() и getDeclaredFields() не возвращают поля класса-родителя!

Возникает вопрос: где может пригодится рефлексивный вызов конструкторов?
Современные технологии java, как уже говорилось в начале, не обходятся без
Reflection API.
Например, DI (Dependency Injection), где аннотации в сочетании с рефлексией методов
и конструкторов образуют популярную в Android разработке библиотеку Darer.

Темной стороной java рефлексия называется не зря. Она напрочь ломает парадигму ООП.
В java инкапсуляция служит для сокрытия и ограничения доступа одних компонентов
программы к другим. Используя модификатор private мы подразумеваем, что доступ к
этому полю будет только в пределах класса, где это поле существует, основываясь на
этом мы строим дальнейшую архитектуру программы. В этой статье мы увидели, как с
помощью рефлексии можно пробираться куда угодно.

Хорошим примером в виде архитектурного решения является порождающий шаблон
проектирования — Singleton. Основная его идея в том, чтобы на протяжении всей работы
программы класс, реализующий этот шаблон был только в одном экземпляре. Осуществляется
это при помощи установки конструктору по умолчанию private модификатор доступа.
И будет очень нехорошо, если какой-то программист со своей рефлексией будет
плодить такие классы.

Защищаться от рефлексии или нет зависит от проекта. Есть специальный класс для защиты
 - SecurityManager.

Так же ньюанс: Поля с модификаторама private+final нельзя изменить.

Сокрытие в целом и модификаторы доступа в частности - это не про защиту от злонамеренных хакеров, взламывающих ваш код.
Модификаторы доступа нужны для предотвращения непреднамеренно ошибочного использования объектов. В больших системах
бывает сложно уследить, что один объект из сотен, в одном из тысяч возможных состояний программы не нарушает
инварианты другого объекта. Весь ООП нужен для снижения сложности кода.

А рефлексия - это чёрных ход в JVM. Рефлексивный код медленный и небезопасный. Он наоборот увеличивает сложность и
сводит к нулю половину достоинств языка. Применять рефлексию допустимо только при разработке инструментальных средств
и фреймворков. И даже при этом стоит стремиться сократить обращение к ней.

